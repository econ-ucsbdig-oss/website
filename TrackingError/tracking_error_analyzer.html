<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio Tracking Error Analyzer</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            padding: 0;
            padding-top: 80px;
        }

        /* Header & Navigation */
        header {
            position: fixed;
            top: 0;
            width: 100%;
            background: rgba(15, 20, 25, 0.95);
            backdrop-filter: blur(20px);
            z-index: 1000;
            padding: 1rem 0;
            transition: all 0.3s ease;
            border-bottom: 1px solid rgba(254, 188, 17, 0.2);
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
        }

        nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 1rem;
            color: white;
            font-size: 1.8rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            text-decoration: none;
        }

        .logo i {
            color: #febc11;
            font-size: 2rem;
            transition: transform 0.3s ease;
        }

        .logo:hover i {
            transform: scale(1.1);
        }

        .nav-links {
            display: flex;
            list-style: none;
            gap: 3rem;
        }

        .nav-links a {
            color: white;
            text-decoration: none;
            font-weight: 600;
            font-size: 1.1rem;
            transition: all 0.3s ease;
            position: relative;
        }

        .nav-links a::after {
            content: '';
            position: absolute;
            width: 0;
            height: 2px;
            bottom: -5px;
            left: 0;
            background: #febc11;
            transition: width 0.3s ease;
        }

        .nav-links a:hover::after {
            width: 100%;
        }

        .nav-links a:hover {
            color: #febc11;
            transform: translateY(-2px);
        }

        .portfolio-link {
            background: linear-gradient(135deg, #28a745, #20c997) !important;
            color: white !important;
            padding: 0.5rem 1rem !important;
            border-radius: 20px !important;
            font-weight: 600 !important;
            transition: all 0.3s ease !important;
        }

        .portfolio-link:hover {
            background: linear-gradient(135deg, #20c997, #28a745) !important;
            color: white !important;
            transform: translateY(-3px) !important;
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3) !important;
        }

        /* Mobile Menu */
        .mobile-menu-toggle {
            display: none;
            flex-direction: column;
            cursor: pointer;
            padding: 0.5rem;
        }

        .mobile-menu-toggle span {
            width: 25px;
            height: 3px;
            background: #febc11;
            margin: 3px 0;
            transition: 0.3s;
            border-radius: 2px;
        }

        .mobile-menu-toggle.active span:nth-child(1) {
            transform: rotate(-45deg) translate(-5px, 6px);
        }

        .mobile-menu-toggle.active span:nth-child(2) {
            opacity: 0;
        }

        .mobile-menu-toggle.active span:nth-child(3) {
            transform: rotate(45deg) translate(-5px, -6px);
        }

        @media (max-width: 768px) {
            body {
                padding-top: 70px;
            }

            .mobile-menu-toggle {
                display: flex;
            }

            .nav-links {
                position: fixed;
                top: 70px;
                left: -100%;
                width: 100%;
                height: calc(100vh - 70px);
                background: rgba(0, 0, 0, 0.95);
                flex-direction: column;
                justify-content: flex-start;
                align-items: center;
                padding-top: 3rem;
                transition: left 0.3s ease;
                backdrop-filter: blur(20px);
            }

            .nav-links.active {
                left: 0;
            }

            .nav-links li {
                margin: 1rem 0;
            }

            .nav-links a {
                font-size: 1.5rem;
            }
        }

        .container {
            margin: 20px auto;
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            padding: 30px;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .input-section {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 8px;
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 18px;
            color: #333;
            margin-bottom: 15px;
            font-weight: 600;
            border-bottom: 2px solid #1e3c72;
            padding-bottom: 5px;
        }

        .input-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
        }

        label {
            font-weight: 500;
            margin-bottom: 5px;
            color: #555;
            font-size: 14px;
        }

        input, select {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #1e3c72;
        }

        .holdings-table {
            width: 100%;
            margin-top: 15px;
            border-collapse: collapse;
        }

        .holdings-table th,
        .holdings-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .holdings-table th {
            background: #667eea;
            color: white;
            font-weight: 500;
        }

        .holdings-table input {
            width: 90%;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }

        .holdings-table input:focus {
            outline: none;
            border-color: #1e3c72;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #1e3c72;
            color: white;
        }

        .btn-primary:hover {
            background: #2a5298;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(30, 60, 114, 0.3);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
            margin-left: 10px;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }

        .results-section {
            margin-top: 30px;
            display: none;
        }

        .metric-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 20px;
            border-radius: 8px;
            color: white;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .metric-label {
            font-size: 12px;
            opacity: 0.9;
            margin-bottom: 5px;
        }

        .metric-value {
            font-size: 24px;
            font-weight: 600;
        }

        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .results-table th,
        .results-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .results-table th {
            background: #1e3c72;
            color: white;
            font-weight: 500;
            position: sticky;
            top: 0;
        }

        .results-table tr:hover {
            background: #f8f9fa;
        }

        .positive {
            color: #28a745;
        }

        .negative {
            color: #dc3545;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
            display: none;
        }

        .success {
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
        }

        .table-container {
            overflow-x: auto;
            margin-bottom: 30px;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .summary-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .summary-table th,
        .summary-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .summary-table th {
            background: #667eea;
            color: white;
            font-weight: 500;
        }

        .summary-table tr:hover {
            background: #f8f9fa;
        }

        .chart-card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 16px;
        }

        .chart-header {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 10px;
        }

        .chart-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }

        .chart-subtitle {
            font-size: 12px;
            color: #666;
            margin-top: 2px;
        }

        .legend {
            display: flex;
            gap: 14px;
            flex-wrap: wrap;
            font-size: 12px;
            color: #444;
        }

        .legend-item {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
        }

        .legend-swatch {
            width: 10px;
            height: 10px;
            border-radius: 2px;
        }

        #equityCurveSvg {
            width: 100%;
            height: 260px;
            display: block;
        }

        .axis-label {
            fill: #666;
            font-size: 11px;
        }

        .gridline {
            stroke: rgba(0,0,0,0.08);
            stroke-width: 1;
        }

        .axis-line {
            stroke: rgba(0,0,0,0.25);
            stroke-width: 1;
        }

        /* Multi-Sleeve Portfolio Styles */
        .sleeve-allocation {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 25px;
            border: 2px solid #dee2e6;
        }

        .sleeve-row {
            display: grid;
            grid-template-columns: 200px 120px 80px 1fr;
            gap: 15px;
            align-items: center;
            padding: 12px;
            background: white;
            border-radius: 6px;
            margin-bottom: 10px;
            border-left: 4px solid transparent;
        }

        .sleeve-row.managed-core {
            border-left-color: #1e3c72;
        }

        .sleeve-row.passive-index {
            border-left-color: #28a745;
        }

        .sleeve-row.alpha-sleeve {
            border-left-color: #fd7e14;
        }

        .sleeve-label {
            font-weight: 600;
            color: #333;
        }

        .sleeve-weight-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .sleeve-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sleeve-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .sleeve-details {
            display: none;
            margin-top: 10px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid #667eea;
        }

        .sleeve-details.visible {
            display: block;
        }

        .weight-summary {
            padding: 12px;
            background: white;
            border-radius: 6px;
            margin-top: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
        }

        .weight-total {
            font-size: 18px;
        }

        .weight-total.valid {
            color: #28a745;
        }

        .weight-total.invalid {
            color: #dc3545;
        }

        .sleeve-attribution {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }

        .attribution-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .attribution-card {
            background: white;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #667eea;
        }

        .attribution-card.passive {
            border-left-color: #28a745;
        }

        .attribution-card.alpha {
            border-left-color: #fd7e14;
        }

        .attribution-value {
            font-size: 24px;
            font-weight: 700;
            color: #333;
            margin: 10px 0;
        }

        .attribution-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Sleeve Badge Styles */
        .sleeve-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .sleeve-badge.sleeve-managed-core {
            background-color: #e8eef7;
            color: #1e3c72;
        }

        .sleeve-badge.sleeve-passive-index {
            background-color: #d4edda;
            color: #28a745;
        }

        .sleeve-badge.sleeve-alpha-sleeve {
            background-color: #ffe5d0;
            color: #fd7e14;
        }

        /* Sleeve Attribution Section */
        .sleeve-attribution {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 25px;
            border: 2px solid #dee2e6;
        }

        .sleeve-attribution-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .sleeve-attribution-item {
            background: white;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #1e3c72;
        }

        .sleeve-attribution-item.passive {
            border-left-color: #28a745;
        }

        .sleeve-attribution-item.alpha {
            border-left-color: #fd7e14;
        }

        .sleeve-attribution-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
        }

        .sleeve-attribution-value {
            font-size: 24px;
            font-weight: 700;
            color: #1e3c72;
            margin-bottom: 4px;
        }

        .sleeve-attribution-item.passive .sleeve-attribution-value {
            color: #28a745;
        }

        .sleeve-attribution-item.alpha .sleeve-attribution-value {
            color: #fd7e14;
        }

        .sleeve-attribution-percent {
            font-size: 14px;
            color: #666;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header>
        <nav>
            <a href="../index.html" class="logo">
                <i class="fas fa-chart-line"></i>
                <span>DIG</span>
            </a>
            <ul class="nav-links" id="navLinks">
                <li><a href="../index.html">Home</a></li>
                <li><a href="../index.html#board">Advisory Board</a></li>
                <li><a href="../portfolio.html" class="portfolio-link">ðŸ“Š Live Portfolio</a></li>
                <li><a href="tracking_error_analyzer.html">ðŸ“ˆ Tracking Error</a></li>
            </ul>
            <div class="mobile-menu-toggle" id="mobileMenuToggle">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </nav>
    </header>

    <div class="container">
        <h1>Portfolio Tracking Error Analyzer</h1>
        <p class="subtitle">Analyze tracking error contributions at equity and sector levels</p>

        <!-- Sleeve Allocation Section -->
        <div class="sleeve-allocation">
            <h2 class="section-title">Portfolio Structure</h2>
            <p style="margin-bottom: 15px; color: #666; font-size: 14px;">Configure your portfolio sleeves. Weights must sum to 100%.</p>

            <!-- Managed Core Sleeve -->
            <div class="sleeve-row managed-core">
                <div class="sleeve-label">Managed Core</div>
                <div>
                    <input type="number" id="managedCoreWeight" class="sleeve-weight-input" value="100" min="0" max="100" step="0.1" onchange="updateSleeveWeights()">
                </div>
                <div class="sleeve-toggle">
                    <input type="checkbox" id="managedCoreEnabled" checked disabled>
                    <label style="margin: 0; font-size: 13px;">Active</label>
                </div>
                <div style="color: #666; font-size: 13px;">Core portfolio holdings (always enabled)</div>
            </div>

            <!-- Passive Index Sleeve -->
            <div class="sleeve-row passive-index">
                <div class="sleeve-label">Passive Index</div>
                <div>
                    <input type="number" id="passiveIndexWeight" class="sleeve-weight-input" value="0" min="0" max="100" step="0.1" onchange="updateSleeveWeights()" disabled>
                </div>
                <div class="sleeve-toggle">
                    <input type="checkbox" id="passiveIndexEnabled" onchange="toggleSleeve('passiveIndex')">
                    <label style="margin: 0; font-size: 13px;">Enable</label>
                </div>
                <div>
                    <select id="passiveIndexHolding" style="padding: 8px; border-radius: 4px; border: 1px solid #ddd; width: 100%;" disabled>
                        <option value="">Select Index</option>
                        <option value="VOO">VOO (S&P 500 ETF)</option>
                        <option value="SPXE">SPXE (S&P 500 ex-Energy)</option>
                    </select>
                </div>
            </div>

            <!-- Alpha Sleeve -->
            <div class="sleeve-row alpha-sleeve">
                <div class="sleeve-label">Alpha Sleeve</div>
                <div>
                    <input type="number" id="alphaWeight" class="sleeve-weight-input" value="0" min="0" max="100" step="0.1" onchange="updateSleeveWeights()" disabled>
                </div>
                <div class="sleeve-toggle">
                    <input type="checkbox" id="alphaEnabled" onchange="toggleSleeve('alpha')">
                    <label style="margin: 0; font-size: 13px;">Enable</label>
                </div>
                <div style="color: #666; font-size: 13px;">Custom high-conviction holdings</div>
            </div>

            <!-- Weight Summary -->
            <div class="weight-summary">
                <span>Total Portfolio Weight:</span>
                <span id="totalWeight" class="weight-total valid">100.0%</span>
            </div>
        </div>

        <!-- Alpha Sleeve Holdings Section (Initially Hidden) -->
        <div id="alphaSleeveSection" class="input-section" style="display: none;">
            <h2 class="section-title">Alpha Sleeve Holdings</h2>
            <p style="margin-bottom: 15px; color: #666; font-size: 14px;">Add holdings for your alpha sleeve. Weights should sum to 100% within this sleeve.</p>

            <div style="margin-bottom: 15px;">
                <button class="btn btn-secondary" onclick="loadAlphaSamplePortfolio()">Load Sample Alpha Holdings</button>
                <button class="btn btn-secondary" onclick="clearAlphaHoldings()">Clear Alpha Holdings</button>
            </div>

            <table class="holdings-table" id="alphaHoldingsTable">
                <thead>
                    <tr>
                        <th>Ticker</th>
                        <th>Weight (%)</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody id="alphaHoldingsBody">
                    <!-- Alpha holdings will be added here -->
                </tbody>
            </table>

            <div style="margin-top: 15px;">
                <input type="text" id="newAlphaTicker" placeholder="Ticker (e.g., AAPL)" style="padding: 10px; border: 1px solid #ddd; border-radius: 5px; margin-right: 10px; width: 150px;">
                <input type="number" id="newAlphaWeight" placeholder="Weight %" min="0" max="100" step="0.1" style="padding: 10px; border: 1px solid #ddd; border-radius: 5px; margin-right: 10px; width: 120px;">
                <button class="btn btn-primary" onclick="addAlphaHolding()">Add Holding</button>
            </div>

            <div style="margin-top: 10px;">
                <strong>Alpha Sleeve Internal Weight Total:</strong> <span id="alphaInternalTotal">0.0%</span>
            </div>
        </div>

        <div class="input-section">
            <h2 class="section-title">Managed Core Holdings</h2>
            <div style="margin-bottom: 15px;">
                <label>Add Holdings (Ticker and Weight - Sector auto-detected):</label>
                <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <input type="text" id="newTicker" placeholder="Ticker (e.g., AAPL)" style="flex: 1;">
                    <input type="number" id="newWeight" placeholder="Weight %" step="0.01" style="flex: 1;">
                    <button class="btn btn-primary btn-small" onclick="addHolding()">Add</button>
                </div>
            </div>

            <table class="holdings-table" id="holdingsTable">
                <thead>
                    <tr>
                        <th>Ticker</th>
                        <th>Weight (%)</th>
                        <th>Sector</th>
                        <th>Action</th>
                    </tr>
                </thead>
                <tbody id="holdingsBody">
                    <!-- Holdings will be added here -->
                </tbody>
            </table>

            <div style="margin-top: 10px; margin-bottom: 15px;">
                <strong>Managed Core Internal Weight Total:</strong> <span id="managedCoreInternalTotal">0.0%</span>
            </div>

            <div class="btn-group">
                <button class="btn btn-secondary btn-small" onclick="loadSamplePortfolio()">Load Sample Portfolio</button>
                <button class="btn btn-secondary btn-small" onclick="loadShadowPortfolio()">Load Shadow Portfolio</button>
                <button class="btn btn-secondary btn-small" onclick="normalizeWeights()">Normalize to 100%</button>
                <button class="btn btn-secondary btn-small" onclick="clearAllHoldings()">Clear All Holdings</button>
            </div>
            <div class="btn-group" style="margin-top: 10px;">
                <button class="btn btn-secondary btn-small" onclick="downloadHoldingsCSV()">Download Holdings CSV</button>
                <button class="btn btn-secondary btn-small" onclick="document.getElementById('csvUpload').click()">Upload Holdings CSV</button>
                <input type="file" id="csvUpload" accept=".csv" style="display: none;" onchange="uploadHoldingsCSV(event)">
            </div>
        </div>

        <div class="input-section">
            <h2 class="section-title">2. Benchmark & Parameters</h2>
            <div class="input-grid">
                <div class="input-group">
                    <label for="benchmark">Benchmark:</label>
                    <select id="benchmark">
                        <option value="^GSPC">S&P 500 (SPX)</option>
                        <option value="SPXE">S&P 500 ex-Energy (SPXE)</option>
                    </select>
                </div>

                <div class="input-group">
                    <label for="period">Time Horizon:</label>
                    <select id="period">
                        <option value="3mo">3 Months</option>
                        <option value="1y" selected>1 Year</option>
                        <option value="3y">3 Years</option>
                        <option value="custom">Custom Date Range</option>
                    </select>
                </div>

                <div class="input-group">
                    <label for="frequency">Frequency:</label>
                    <select id="frequency">
                        <option value="1d" selected>Daily</option>
                        <option value="1wk">Weekly</option>
                    </select>
                </div>

                <div class="input-group">
                    <label for="sectorAggregation">Sector Grouping:</label>
                    <select id="sectorAggregation">
                        <option value="gics11" selected>GICS 11 Sectors</option>
                        <option value="custom6">Custom 6 Sectors</option>
                    </select>
                </div>
            </div>

            <div id="customDateRange" style="display: none; margin-top: 15px;">
                <div class="input-grid">
                    <div class="input-group">
                        <label for="startDate">Start Date:</label>
                        <input type="date" id="startDate" />
                    </div>
                    <div class="input-group">
                        <label for="endDate">End Date:</label>
                        <input type="date" id="endDate" />
                    </div>
                </div>
            </div>

            <button class="btn btn-primary" onclick="calculateTrackingError()" style="margin-top: 20px;">
                Calculate Tracking Error
            </button>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p style="margin-top: 10px; color: #666;">Fetching data via proxy server...</p>
            <p style="margin-top: 5px; color: #999; font-size: 0.9em;">This may take a few minutes depending on number of holdings</p>
        </div>

        <div class="error" id="error"></div>

        <div class="results-section" id="results">
            <h2 class="section-title">Results</h2>

            <div class="metric-cards">
                <div class="metric-card">
                    <div class="metric-label">Portfolio Return</div>
                    <div class="metric-value" id="portfolioReturn">-</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Benchmark Return</div>
                    <div class="metric-value" id="benchmarkReturn">-</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Active Return</div>
                    <div class="metric-value" id="activeReturn">-</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Portfolio Tracking Error</div>
                    <div class="metric-value" id="portfolioTE">-</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Number of Holdings</div>
                    <div class="metric-value" id="numHoldings">-</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Analysis Period</div>
                    <div class="metric-value" id="analysisPeriod">-</div>
                </div>
            </div>

            <h3 class="section-title">Equity-Level Tracking Error Contributions</h3>
            <div class="table-container">
                <table class="results-table" id="equityResults">
                    <thead>
                        <tr>
                            <th onclick="sortEquityTable(0)" style="cursor: pointer; text-align: left;">Ticker â†•</th>
                            <th onclick="sortEquityTable(1)" style="cursor: pointer; text-align: left;">Sector â†•</th>
                            <th onclick="sortEquityTable(2)" style="cursor: pointer; text-align: center; line-height: 1.2; padding: 8px 4px;">Active<br>Weight<br>(%) â†•</th>
                            <th onclick="sortEquityTable(3)" style="cursor: pointer; text-align: center; line-height: 1.2; padding: 8px 4px;">Return<br>(%) â†•</th>
                            <th onclick="sortEquityTable(4)" style="cursor: pointer; text-align: center; line-height: 1.2; padding: 8px 4px;">Active<br>Return<br>(%) â†•</th>
                            <th onclick="sortEquityTable(5)" style="cursor: pointer; text-align: center; line-height: 1.2; padding: 8px 4px;">CTE<br>(%) â†•</th>
                            <th onclick="sortEquityTable(6)" style="cursor: pointer; text-align: center; line-height: 1.2; padding: 8px 4px;">% of<br>Return â†•</th>
                            <th onclick="sortEquityTable(7)" style="cursor: pointer; text-align: center; line-height: 1.2; padding: 8px 4px;">% of<br>TE â†•</th>
                        </tr>
                    </thead>
                    <tbody id="equityResultsBody">
                    </tbody>
                </table>
            </div>

            <h3 class="section-title">Sector-Level Tracking Error Contributions</h3>
            <div class="table-container">
                <table class="results-table" id="sectorResults">
                    <thead>
                        <tr>
                            <th>Sector</th>
                            <th>Active Return (%)</th>
                            <th>CTE (%)</th>
                            <th>% of Return</th>
                            <th>% of TE</th>
                        </tr>
                    </thead>
                    <tbody id="sectorResultsBody">
                    </tbody>
                </table>
            </div>

            <!-- Sleeve Attribution Table (only shown for multi-sleeve portfolios) -->
            <div id="sleeveAttributionSection" style="display: none;">
                <h3 class="section-title">Sleeve Attribution to Tracking Error</h3>
                <div class="table-container">
                    <table class="results-table" id="sleeveAttributionTable">
                        <thead>
                            <tr>
                                <th>Sleeve</th>
                                <th>Portfolio Weight (%)</th>
                                <th>Active Return (%)</th>
                                <th>CTE (%)</th>
                                <th>% of Return</th>
                                <th>% of TE</th>
                            </tr>
                        </thead>
                        <tbody id="sleeveAttributionBody">
                        </tbody>
                    </table>
                </div>
            </div>

            <h3 class="section-title">Portfolio Summary</h3>
                <table class="summary-table" id="portfolioSummary">
                    <thead>
                        <tr>
                            <th>Metric</th>
                            <th>Value</th>
                        </tr>
                    </thead>
                    <tbody id="portfolioSummaryBody">
                    </tbody>
                </table>
            </div>

            <div class="btn-group" style="margin-top: -10px; margin-bottom: 20px;">
                <button class="btn btn-secondary btn-small" onclick="downloadDebugCSV()">Download Debug CSV</button>
            </div>

            <h3 class="section-title">Growth of $10,000 (Portfolio vs Benchmark)</h3>
            <div class="chart-card" style="margin-bottom: 20px;">
                <div class="chart-header">
                    <div>
                        <div class="chart-title">Cumulative value from $10,000 at period start</div>
                        <div class="chart-subtitle" id="equityCurveSubtitle">-</div>
                    </div>
                    <div class="legend" aria-label="Chart legend">
                        <span class="legend-item"><span class="legend-swatch" style="background:#667eea"></span>Portfolio</span>
                        <span class="legend-item"><span class="legend-swatch" style="background:#2ea44f"></span>Benchmark</span>
                    </div>
                </div>
                <svg id="equityCurveSvg" viewBox="0 0 900 260" preserveAspectRatio="none" role="img" aria-label="Equity curve chart"></svg>
            </div>

            <h3 class="section-title">Portfolio vs Benchmark Returns (Scatter Plot)</h3>
            <div class="chart-card" style="margin-bottom: 20px;">
                <div class="chart-header">
                    <div>
                        <div class="chart-title">Daily returns with regression line (slope = Beta)</div>
                        <div class="chart-subtitle" id="scatterSubtitle">-</div>
                    </div>
                    <div class="legend" aria-label="Chart legend">
                        <span class="legend-item"><span class="legend-swatch" style="background:#667eea"></span>Daily Returns</span>
                        <span class="legend-item"><span class="legend-swatch" style="background:#ef4444"></span>Regression Line (Beta)</span>
                    </div>
                </div>
                <svg id="scatterChartSvg" viewBox="0 0 900 400" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Scatter plot chart"></svg>
            </div>

            <h3 class="section-title">Rolling Tracking Error (60-Day Window)</h3>
            <div class="chart-card" style="margin-bottom: 20px;">
                <div class="chart-header">
                    <div>
                        <div class="chart-title">Portfolio tracking error over time (annualized)</div>
                        <div class="chart-subtitle" id="teChartSubtitle">-</div>
                    </div>
                    <div class="legend" aria-label="Chart legend">
                        <span class="legend-item"><span class="legend-swatch" style="background:#8b5cf6"></span>Rolling TE</span>
                    </div>
                </div>
                <svg id="teChartSvg" viewBox="0 0 900 260" preserveAspectRatio="none" role="img" aria-label="TE chart"></svg>
            </div>

            <h3 class="section-title">Rolling Portfolio Beta (60-Day Window)</h3>
            <div class="chart-card" style="margin-bottom: 20px;">
                <div class="chart-header">
                    <div>
                        <div class="chart-title">Portfolio Beta vs Benchmark over time</div>
                        <div class="chart-subtitle" id="betaChartSubtitle">-</div>
                    </div>
                    <div class="legend" aria-label="Chart legend">
                        <span class="legend-item"><span class="legend-swatch" style="background:#f59e0b"></span>Portfolio Beta</span>
                        <span class="legend-item"><span class="legend-swatch" style="background:#94a3b8"></span>Beta = 1.0 (Neutral)</span>
                    </div>
                </div>
                <svg id="betaChartSvg" viewBox="0 0 900 260" preserveAspectRatio="none" role="img" aria-label="Beta chart"></svg>
            </div>

            <div class="success" id="verification"></div>
        </div>
    </div>

    <script>
        // Store portfolio holdings and benchmark weights
        let holdings = [];  // Managed Core holdings
        let benchmarkWeights = {};

        // Multi-Sleeve Portfolio Structure
        const portfolio = {
            managedCore: {
                enabled: true,
                weight: 100,
                holdings: []  // This will reference 'holdings' array
            },
            passiveIndex: {
                enabled: false,
                weight: 0,
                holding: null  // 'VOO' or 'SPXE'
            },
            alpha: {
                enabled: false,
                weight: 0,
                holdings: []  // Separate array for alpha holdings
            }
        };

        // Alpha sleeve holdings (separate from managed core)
        let alphaHoldings = [];

        // Set default date values
        const today = new Date();
        const oneYearAgo = new Date();
        oneYearAgo.setFullYear(today.getFullYear() - 1);

        document.addEventListener('DOMContentLoaded', function() {
            // Set default dates
            document.getElementById('endDate').valueAsDate = today;
            document.getElementById('startDate').valueAsDate = oneYearAgo;

            // Add event listener for period dropdown
            document.getElementById('period').addEventListener('change', function() {
                if (this.value === 'custom') {
                    document.getElementById('customDateRange').style.display = 'block';
                } else {
                    document.getElementById('customDateRange').style.display = 'none';
                }
            });
        });

        // Sector aggregation mapping
        const sectorAggregationMap = {
            'Technology': 'Tech & Communication',
            'Communication Services': 'Tech & Communication',
            'Consumer Discretionary': 'Consumer',
            'Consumer Staples': 'Consumer',
            'Utilities': 'Utilities & Real Estate',
            'Real Estate': 'Utilities & Real Estate',
            'Materials': 'Materials & Industrials',
            'Industrials': 'Materials & Industrials',
            'Healthcare': 'Healthcare',
            'Financials': 'Financials',
            'Energy': 'Energy'
        };

        // Sector mapping for common stocks
        const sectorMap = {
            'AMZN': 'Consumer Discretionary',
            'ASML': 'Technology',
            'BLD': 'Industrials',
            'CEG': 'Utilities',
            'COST': 'Consumer Staples',
            'DXCM': 'Healthcare',
            'FCX': 'Materials',
            'FLUT': 'Consumer Discretionary',
            'GOOGL': 'Communication Services',
            'HIMS': 'Healthcare',
            'IHI': 'Healthcare',
            'JPM': 'Financials',
            'MSFT': 'Technology',
            'NUKZ': 'Energy',
            'PANW': 'Technology',
            'PSA': 'Real Estate',
            'SCHW': 'Financials',
            'SNOW': 'Technology',
            'TSM': 'Technology',
            'VRT': 'Industrials',
            'AAPL': 'Technology',
            'NVDA': 'Technology',
            'META': 'Communication Services',
            'TSLA': 'Consumer Discretionary',
            'V': 'Financials',
            'JNJ': 'Healthcare',
            'UNH': 'Healthcare',
            'XOM': 'Energy',
            'CVX': 'Energy',

            // Shadow portfolio additions (best-effort, can be overridden by live lookup)
            'CSCO': 'Technology',
            'DDOG': 'Technology',
            'CAN': 'Technology',
            'KO': 'Consumer Staples',
            'BLK': 'Financials',
            'BRK.B': 'Financials',
            'NVO': 'Healthcare',
            'LLY': 'Healthcare',
            'BSX': 'Healthcare',
            'TMO': 'Healthcare',
            'GE': 'Industrials',
            'STRL': 'Industrials',
            'RS': 'Materials',
            'ECL': 'Materials',
            'GLD': 'Materials',
            'UUP': 'Financials',
            'DLR': 'Real Estate',
            'VICI': 'Real Estate',
            'CCJ': 'Energy'
        };

        // Auto-detect sector
        async function detectSector(ticker) {
            // First check our local map
            if (sectorMap[ticker.toUpperCase()]) {
                return sectorMap[ticker.toUpperCase()];
            }

            // Try to fetch from Yahoo Finance using CORS proxy
            try {
                const url = `https://corsproxy.io/?https://query2.finance.yahoo.com/v10/finance/quoteSummary/${ticker}?modules=assetProfile`;
                const response = await fetch(url);
                const data = await response.json();

                if (data.quoteSummary && data.quoteSummary.result && data.quoteSummary.result[0]) {
                    const profile = data.quoteSummary.result[0].assetProfile;
                    return profile.sector || 'Unknown';
                }
            } catch (error) {
                console.log(`Could not fetch sector for ${ticker}, using Unknown`);
            }

            return 'Unknown';
        }

        // Add a holding to the portfolio
        async function addHolding() {
            const ticker = document.getElementById('newTicker').value.trim().toUpperCase();
            const weight = parseFloat(document.getElementById('newWeight').value);

            if (!ticker || isNaN(weight)) {
                alert('Please enter ticker and weight');
                return;
            }

            // Show loading
            document.getElementById('loading').style.display = 'block';

            // Auto-detect sector
            const sector = await detectSector(ticker);

            holdings.push({ ticker, weight, sector });
            updateHoldingsTable();

            // Clear inputs
            document.getElementById('newTicker').value = '';
            document.getElementById('newWeight').value = '';

            document.getElementById('loading').style.display = 'none';
        }

        // Update weight from table input
        function updateWeight(index, newWeight) {
            holdings[index].weight = parseFloat(newWeight);
            // Update the managed core internal weight total
            const managedCoreTotal = holdings.reduce((sum, h) => sum + h.weight, 0);
            document.getElementById('managedCoreInternalTotal').textContent = managedCoreTotal.toFixed(1) + '%';
        }

        // Remove a holding
        function removeHolding(index) {
            holdings.splice(index, 1);
            updateHoldingsTable();
        }

        // Update the holdings table
        function updateHoldingsTable() {
            const tbody = document.getElementById('holdingsBody');
            tbody.innerHTML = '';

            holdings.forEach((holding, index) => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>${holding.ticker}</td>
                    <td><input type="number" value="${holding.weight.toFixed(2)}" step="0.01" onchange="updateWeight(${index}, this.value)"></td>
                    <td>${holding.sector}</td>
                    <td><button class="btn btn-secondary btn-small" onclick="removeHolding(${index})">Remove</button></td>
                `;
            });

            // Update managed core internal weight total
            const managedCoreTotal = holdings.reduce((sum, h) => sum + h.weight, 0);
            document.getElementById('managedCoreInternalTotal').textContent = managedCoreTotal.toFixed(1) + '%';
        }

        // Normalize weights to 100%
        function normalizeWeights() {
            const total = holdings.reduce((sum, h) => sum + h.weight, 0);
            if (total > 0) {
                holdings.forEach(h => {
                    h.weight = (h.weight / total) * 100;
                });
                updateHoldingsTable();
            }
        }

        // Clear all holdings
        function clearAllHoldings() {
            if (holdings.length === 0) {
                alert('No holdings to clear.');
                return;
            }

            if (confirm('Are you sure you want to clear all holdings from the Managed Core? This cannot be undone.')) {
                holdings = [];
                updateHoldingsTable();
            }
        }

        // Download holdings as CSV
        function downloadHoldingsCSV() {
            if (holdings.length === 0) {
                alert('No holdings to export. Add some holdings first.');
                return;
            }

            // Create CSV content
            const header = 'Ticker,Weight (%),Sector\n';
            const rows = holdings.map(h => `${h.ticker},${h.weight.toFixed(2)},${h.sector}`);
            const csv = header + rows.join('\n');

            // Create download link
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `portfolio_holdings_${new Date().toISOString().slice(0,10)}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Upload holdings from CSV
        function uploadHoldingsCSV(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csv = e.target.result;
                    const lines = csv.split('\n').filter(line => line.trim());

                    if (lines.length < 2) {
                        alert('CSV file is empty or invalid');
                        return;
                    }

                    // Parse CSV (expecting: Ticker,Weight,Sector)
                    for (let i = 1; i < lines.length; i++) { // Skip header
                        const line = lines[i].trim();
                        if (!line) continue;

                        const parts = line.split(',').map(s => s.trim());
                        if (parts.length >= 2) {
                            const ticker = parts[0].toUpperCase();
                            const weight = parseFloat(parts[1]);
                            const sector = parts[2] || 'Unknown';

                            if (ticker && !isNaN(weight)) {
                                holdings.push({ ticker, weight, sector });
                            }
                        }
                    }

                    updateHoldingsTable();
                    alert('Holdings loaded successfully!');
                } catch (error) {
                    alert('Error parsing CSV: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // ========== MULTI-SLEEVE MANAGEMENT FUNCTIONS ==========

        function toggleSleeve(sleeveName) {
            const enabled = document.getElementById(`${sleeveName}Enabled`).checked;
            const weightInput = document.getElementById(`${sleeveName}Weight`);

            if (sleeveName === 'passiveIndex') {
                portfolio.passiveIndex.enabled = enabled;
                weightInput.disabled = !enabled;
                document.getElementById('passiveIndexHolding').disabled = !enabled;

                if (!enabled) {
                    portfolio.passiveIndex.weight = 0;
                    weightInput.value = 0;
                }
            } else if (sleeveName === 'alpha') {
                portfolio.alpha.enabled = enabled;
                weightInput.disabled = !enabled;
                document.getElementById('alphaSleeveSection').style.display = enabled ? 'block' : 'none';

                if (!enabled) {
                    portfolio.alpha.weight = 0;
                    weightInput.value = 0;
                }
            }

            updateSleeveWeights();
        }

        function updateSleeveWeights() {
            // Get weights from inputs
            const managedCoreWeight = parseFloat(document.getElementById('managedCoreWeight').value) || 0;
            const passiveIndexWeight = parseFloat(document.getElementById('passiveIndexWeight').value) || 0;
            const alphaWeight = parseFloat(document.getElementById('alphaWeight').value) || 0;

            // Update portfolio structure
            portfolio.managedCore.weight = managedCoreWeight;
            portfolio.passiveIndex.weight = passiveIndexWeight;
            portfolio.alpha.weight = alphaWeight;

            // Calculate total
            const total = managedCoreWeight + passiveIndexWeight + alphaWeight;

            // Update display
            const totalElement = document.getElementById('totalWeight');
            totalElement.textContent = total.toFixed(1) + '%';

            // Update validity styling
            const isValid = Math.abs(total - 100) < 0.01;
            totalElement.className = 'weight-total ' + (isValid ? 'valid' : 'invalid');

            return isValid;
        }

        // Alpha Sleeve Management Functions
        function addAlphaHolding() {
            const ticker = document.getElementById('newAlphaTicker').value.trim().toUpperCase();
            const weight = parseFloat(document.getElementById('newAlphaWeight').value);

            if (!ticker || isNaN(weight) || weight <= 0) {
                alert('Please enter a valid ticker and weight');
                return;
            }

            alphaHoldings.push({ ticker, weight });
            updateAlphaHoldingsTable();

            // Clear inputs
            document.getElementById('newAlphaTicker').value = '';
            document.getElementById('newAlphaWeight').value = '';
        }

        function removeAlphaHolding(index) {
            alphaHoldings.splice(index, 1);
            updateAlphaHoldingsTable();
        }

        function updateAlphaHoldingsTable() {
            const tbody = document.getElementById('alphaHoldingsBody');
            tbody.innerHTML = '';

            let total = 0;
            alphaHoldings.forEach((holding, index) => {
                total += holding.weight;
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>${holding.ticker}</td>
                    <td><input type="number" value="${holding.weight}" step="0.1" min="0"
                        onchange="updateAlphaWeight(${index}, this.value)"
                        style="width: 100px; padding: 5px;"></td>
                    <td><button class="btn btn-secondary" onclick="removeAlphaHolding(${index})">Remove</button></td>
                `;
            });

            // Update internal total
            document.getElementById('alphaInternalTotal').textContent = total.toFixed(1) + '%';
            document.getElementById('alphaInternalTotal').style.color = Math.abs(total - 100) < 0.01 ? '#28a745' : '#dc3545';
        }

        function updateAlphaWeight(index, newWeight) {
            alphaHoldings[index].weight = parseFloat(newWeight) || 0;
            updateAlphaHoldingsTable();
        }

        function clearAlphaHoldings() {
            alphaHoldings = [];
            updateAlphaHoldingsTable();
        }

        function loadAlphaSamplePortfolio() {
            alphaHoldings = [
                { ticker: 'NVDA', weight: 30 },
                { ticker: 'TSLA', weight: 25 },
                { ticker: 'AVGO', weight: 20 },
                { ticker: 'AMD', weight: 15 },
                { ticker: 'PLTR', weight: 10 }
            ];
            updateAlphaHoldingsTable();
        }

        // ========== END MULTI-SLEEVE FUNCTIONS ==========

        // ========== HOLDINGS AGGREGATION FUNCTION ==========

        function aggregatePortfolioHoldings() {
            const aggregated = [];

            // Validate sleeve weights sum to 100%
            if (!updateSleeveWeights()) {
                alert('Sleeve weights must sum to 100% before calculating. Please adjust your portfolio structure.');
                return null;
            }

            // 1. Managed Core Sleeve
            if (portfolio.managedCore.enabled && portfolio.managedCore.weight > 0) {
                const sleeveWeight = portfolio.managedCore.weight / 100;
                const internalSum = holdings.reduce((sum, h) => sum + h.weight, 0);

                if (internalSum > 0) {
                    holdings.forEach(h => {
                        aggregated.push({
                            ticker: h.ticker,
                            weight: (h.weight / internalSum) * sleeveWeight * 100,
                            sector: h.sector,
                            sleeve: 'Managed Core',
                            sleeveWeight: portfolio.managedCore.weight
                        });
                    });
                }
            }

            // 2. Passive Index Sleeve
            if (portfolio.passiveIndex.enabled && portfolio.passiveIndex.weight > 0) {
                const holding = document.getElementById('passiveIndexHolding').value;
                if (!holding) {
                    alert('Please select an index (VOO or SPXE) for the Passive Index sleeve.');
                    return null;
                }

                portfolio.passiveIndex.holding = holding;

                // For index funds like VOO and SPXE, we'll use their price data directly
                // Mark them as index funds so they're handled correctly in the calculation
                const indexHolding = {
                    ticker: holding,
                    weight: portfolio.passiveIndex.weight,
                    sector: 'Index Fund',
                    sleeve: 'Passive Index',
                    sleeveWeight: portfolio.passiveIndex.weight,
                    isIndexFund: true  // Flag to handle differently in calculations
                };
                console.log('ðŸš¨ðŸš¨ðŸš¨ ADDING PASSIVE INDEX HOLDING ðŸš¨ðŸš¨ðŸš¨', indexHolding);
                alert('CODE IS UPDATED! Adding passive index: ' + holding);
                aggregated.push(indexHolding);
            }

            // 3. Alpha Sleeve
            if (portfolio.alpha.enabled && portfolio.alpha.weight > 0) {
                const sleeveWeight = portfolio.alpha.weight / 100;
                const internalSum = alphaHoldings.reduce((sum, h) => sum + h.weight, 0);

                if (internalSum === 0) {
                    alert('Alpha sleeve is enabled but has no holdings. Please add holdings or disable the alpha sleeve.');
                    return null;
                }

                // Validate alpha internal weights sum to ~100%
                if (Math.abs(internalSum - 100) > 1.0) {
                    const proceed = confirm(`Alpha sleeve holdings sum to ${internalSum.toFixed(1)}% instead of 100%. Continue anyway?`);
                    if (!proceed) return null;
                }

                alphaHoldings.forEach(h => {
                    aggregated.push({
                        ticker: h.ticker,
                        weight: (h.weight / internalSum) * sleeveWeight * 100,
                        sector: 'Alpha',  // Will be auto-detected later
                        sleeve: 'Alpha Sleeve',
                        sleeveWeight: portfolio.alpha.weight
                    });
                });
            }

            // Validate we have at least some holdings
            if (aggregated.length === 0) {
                alert('Portfolio has no holdings. Please add holdings to at least one sleeve.');
                return null;
            }

            // Combine duplicate tickers by summing their weights
            const tickerMap = {};
            aggregated.forEach(holding => {
                if (tickerMap[holding.ticker]) {
                    // Ticker already exists, add to its weight
                    tickerMap[holding.ticker].weight += holding.weight;
                    // Preserve isIndexFund flag if either holding has it
                    if (holding.isIndexFund) {
                        tickerMap[holding.ticker].isIndexFund = true;
                    }
                } else {
                    // New ticker, add it to the map
                    tickerMap[holding.ticker] = { ...holding };
                }
            });

            // Convert back to array
            const consolidatedHoldings = Object.values(tickerMap);

            console.log('Aggregated Portfolio Holdings (before consolidation):', aggregated.length);
            console.log('Consolidated Portfolio Holdings (after merging duplicates):', consolidatedHoldings);
            return consolidatedHoldings;
        }

        // ========== END HOLDINGS AGGREGATION ==========

        // ========== BLOOMBERG-STYLE LOOK-THROUGH ==========
        // Decompose index funds into their constituents and calculate net active weights
        async function performLookThrough(aggregatedHoldings, benchmark) {
            await loadIndexFundHoldings();

            // Step 1: Build total portfolio weights by looking through index funds
            const portfolioWeights = {};

            aggregatedHoldings.forEach(holding => {
                if (holding.isIndexFund) {
                    // Look through the index fund
                    let indexHoldings;
                    if (holding.ticker === 'VOO' || holding.ticker === 'SPY') {
                        indexHoldings = vooHoldings;
                    } else if (holding.ticker === 'SPXE') {
                        indexHoldings = spxeHoldings;
                    } else {
                        console.warn(`Unknown index fund: ${holding.ticker}`);
                        return;
                    }

                    // Add each constituent weighted by the index fund's weight
                    const indexWeight = holding.weight / 100; // Convert to decimal
                    Object.entries(indexHoldings).forEach(([ticker, constituentWeight]) => {
                        const contributedWeight = indexWeight * (constituentWeight / 100);
                        portfolioWeights[ticker] = (portfolioWeights[ticker] || 0) + contributedWeight;
                    });
                } else {
                    // Regular stock - add directly
                    const weight = holding.weight / 100; // Convert to decimal
                    portfolioWeights[holding.ticker] = (portfolioWeights[holding.ticker] || 0) + weight;
                }
            });

            // Step 2: Use the global benchmarkWeights (already loaded)
            console.log('Using benchmark weights:', Object.keys(benchmarkWeights).length, 'constituents');

            // Step 3: Calculate net active weights for ALL tickers (portfolio + benchmark)
            const netActiveWeights = {};
            const allTickers = new Set([...Object.keys(portfolioWeights), ...Object.keys(benchmarkWeights)]);

            console.log(`Portfolio tickers: ${Object.keys(portfolioWeights).length}`);
            console.log(`Benchmark tickers: ${Object.keys(benchmarkWeights).length}`);
            console.log(`Total unique tickers: ${allTickers.size}`);

            allTickers.forEach(ticker => {
                const portWeight = (portfolioWeights[ticker] || 0) * 100; // Convert to percentage
                const benchWeight = benchmarkWeights[ticker] || 0;
                const activeWeight = portWeight - benchWeight;

                // Include ALL tickers, even with zero active weight (for completeness)
                // The covariance matrix needs all holdings
                netActiveWeights[ticker] = {
                    portfolioWeight: portWeight,
                    benchmarkWeight: benchWeight,
                    activeWeight: activeWeight
                };
            });

            console.log(`Look-through complete: ${Object.keys(netActiveWeights).length} total equities`);

            // Count how many have non-zero active weights
            const nonZeroCount = Object.values(netActiveWeights).filter(w => Math.abs(w.activeWeight) > 0.0001).length;
            console.log(`  -> ${nonZeroCount} with non-zero active weights`);

            return netActiveWeights;
        }

        // ========== END LOOK-THROUGH ==========

        // Load sample portfolio
        async function loadSamplePortfolio() {
            // Use deterministic sample weights (as provided)
            // Note: these are decimals that sum to ~1.0; UI uses percent.
            const sampleWeights = [
                { ticker: 'GOOGL', weight: 0.137115344 },
                { ticker: 'TSM', weight: 0.13317786 },
                { ticker: 'MSFT', weight: 0.085262946 },
                { ticker: 'AMZN', weight: 0.08254371 },
                { ticker: 'ASML', weight: 0.067965115 },
                { ticker: 'NUKZ', weight: 0.04593891 },
                { ticker: 'IHI', weight: 0.043486015 },
                { ticker: 'SNOW', weight: 0.043446646 },
                { ticker: 'COST', weight: 0.041257698 },
                { ticker: 'JPM', weight: 0.040925414 },
                { ticker: 'VRT', weight: 0.03978943 },
                { ticker: 'CEG', weight: 0.037396943 },
                { ticker: 'PANW', weight: 0.031726237 },
                { ticker: 'FCX', weight: 0.031724505 },
                { ticker: 'SCHW', weight: 0.029381257 },
                { ticker: 'BLD', weight: 0.025975932 },
                { ticker: 'FLUT', weight: 0.024630307 },
                { ticker: 'DXCM', weight: 0.023909695 },
                { ticker: 'HIMS', weight: 0.017191968 },
                { ticker: 'PSA', weight: 0.017154067 }
            ];

            document.getElementById('loading').style.display = 'block';

            try {
                holdings = [];
                for (const h of sampleWeights) {
                    const sector = await detectSector(h.ticker);
                    holdings.push({
                        ticker: h.ticker,
                        weight: h.weight * 100, // convert to percent
                        sector
                    });
                }

                updateHoldingsTable();
            } catch (error) {
                console.error('Error loading sample portfolio:', error);
                alert('Error loading sample portfolio: ' + error.message);
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }

        // Load shadow portfolio (user-provided weights; decimals that sum to ~1.0; UI uses percent)
        async function loadShadowPortfolio() {
            const shadowWeights = [
                { ticker: 'GOOGL', weight: 0.074003295 },
                { ticker: 'META', weight: 0.032376442 },
                { ticker: 'TSM', weight: 0.087878913 },
                { ticker: 'MSFT', weight: 0.10175453 },
                { ticker: 'CSCO', weight: 0.055502471 },
                { ticker: 'DDOG', weight: 0.0555 },
                { ticker: 'CAN', weight: 0.055502471 },
                { ticker: 'AMZN', weight: 0.103943884 },
                { ticker: 'COST', weight: 0.033916186 },
                { ticker: 'KO', weight: 0.021221479 },
                { ticker: 'JPM', weight: 0.052036707 },
                { ticker: 'SCHW', weight: 0.033456 },
                { ticker: 'BLK', weight: 0.030671334 },
                { ticker: 'BRK.B', weight: 0.023247477 },
                { ticker: 'UNH', weight: 0.01739184 },
                { ticker: 'NVO', weight: 0.013908 },
                { ticker: 'LLY', weight: 0.013908 },
                { ticker: 'BSX', weight: 0.013908 },
                { ticker: 'TMO', weight: 0.01043328 },
                { ticker: 'DXCM', weight: 0.02164176 },
                { ticker: 'GE', weight: 0.018644975 },
                { ticker: 'STRL', weight: 0.012429984 },
                { ticker: 'RS', weight: 0.02072 },
                { ticker: 'ECL', weight: 0.02072 },
                { ticker: 'VRT', weight: 0.01035832 },
                { ticker: 'GLD', weight: 0.01035832 },
                { ticker: 'UUP', weight: 0.01035832 },
                { ticker: 'DLR', weight: 0.010247941 },
                { ticker: 'VICI', weight: 0.020540054 },
                { ticker: 'CCJ', weight: 0.00552152 },
                { ticker: 'CEG', weight: 0.007862644 }
            ];

            document.getElementById('loading').style.display = 'block';

            try {
                holdings = [];
                for (const h of shadowWeights) {
                    const sector = await detectSector(h.ticker);
                    holdings.push({
                        ticker: h.ticker,
                        weight: h.weight * 100,
                        sector
                    });
                }
                updateHoldingsTable();
            } catch (error) {
                console.error('Error loading shadow portfolio:', error);
                alert('Error loading shadow portfolio: ' + error.message);
            } finally {
                document.getElementById('loading').style.display = 'none';
            }
        }

        // Load CSV file and parse into {ticker: weight} object
        async function loadCSVWeights(filename) {
            try {
                const response = await fetch(filename);
                const text = await response.text();
                const lines = text.trim().split('\n');
                const weights = {};

                // Skip header row
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;

                    const [ticker, weightStr] = line.split(',');
                    if (ticker && weightStr) {
                        // Remove % sign and convert to decimal
                        const weight = parseFloat(weightStr.replace('%', ''));
                        weights[ticker.trim()] = weight;
                    }
                }

                return weights;
            } catch (error) {
                console.error(`Error loading ${filename}:`, error);
                return {};
            }
        }

        // Cache for index fund holdings
        let vooHoldings = null;
        let spxHoldings = null;
        let spxeHoldings = null;

        // Load index fund holdings from CSV files
        async function loadIndexFundHoldings() {
            if (!vooHoldings) {
                vooHoldings = await loadCSVWeights('vooholdings.csv');
                console.log(`Loaded VOO holdings: ${Object.keys(vooHoldings).length} constituents`);
            }
            if (!spxHoldings) {
                spxHoldings = await loadCSVWeights('spxholdings.csv');
                console.log(`Loaded SPX holdings: ${Object.keys(spxHoldings).length} constituents`);
            }
            if (!spxeHoldings) {
                spxeHoldings = await loadCSVWeights('SPXE Holdings-3.csv');
                console.log(`Loaded SPXE holdings: ${Object.keys(spxeHoldings).length} constituents`);
            }
        }

        // Fetch benchmark constituent weights
        async function fetchBenchmarkWeights(benchmark) {
            await loadIndexFundHoldings();
            benchmarkWeights = {};

            if (benchmark === 'SPXE') {
                return { ...spxeHoldings };
            } else if (benchmark === 'SPY' || benchmark === '^GSPC') {
                return { ...spxHoldings };
            }

            return {};
        }

        // SPXE actual weights from SPXE Holdings-3.csv
        // Generated: 481 holdings totaling 99.80%
        const spxeWeights = {
            'NVDA': 7.99, 'AAPL': 6.69, 'MSFT': 6.25, 'AMZN': 4.09, 'GOOGL': 3.26,
            'AVGO': 2.82, 'GOOG': 2.61, 'META': 2.46, 'TSLA': 2.11, 'BRK.B': 1.58,
            'JPM': 1.55, 'LLY': 1.53, 'V': 1.04, 'JNJ': 0.87, 'WMT': 0.86,
            'MA': 0.83, 'PLTR': 0.72, 'ABBV': 0.72, 'COST': 0.68, 'NFLX': 0.67,
            'MU': 0.66, 'BAC': 0.65, 'HD': 0.6, 'AMD': 0.59, 'GE': 0.59,
            'ORCL': 0.56, 'PG': 0.56, 'UNH': 0.54, 'WFC': 0.51, 'CSCO': 0.51,
            'GS': 0.49, 'CAT': 0.49, 'IBM': 0.48, 'MRK': 0.47, 'KO': 0.45,
            'LRCX': 0.44, 'CRM': 0.44, 'RTX': 0.43, 'PM': 0.42, 'AMAT': 0.4,
            'TMO': 0.4, 'MS': 0.39, 'ABT': 0.38, 'C': 0.38, 'MCD': 0.38,
            'ISRG': 0.37, 'AXP': 0.35, 'LIN': 0.35, 'DIS': 0.35, 'QCOM': 0.34,
            'INTC': 0.33, 'PEP': 0.33, 'AMGN': 0.32, 'INTU': 0.32, 'GEV': 0.31,
            'UBER': 0.31, 'KLAC': 0.31, 'BA': 0.31, 'BKNG': 0.31, 'TJX': 0.3,
            'APP': 0.3, 'SCHW': 0.3, 'APH': 0.3, 'ACN': 0.3, 'T': 0.3,
            'VZ': 0.29, 'TXN': 0.29, 'SPGI': 0.29, 'NEE': 0.28, 'COF': 0.28,
            'NOW': 0.27, 'GILD': 0.27, 'BLK': 0.27, 'DHR': 0.26, 'BSX': 0.25,
            'ADI': 0.25, 'PFE': 0.25, 'ADBE': 0.25, 'LOW': 0.24, 'ANET': 0.23,
            'UNP': 0.23, 'PANW': 0.23, 'MDT': 0.22, 'WELL': 0.22, 'SYK': 0.22,
            'HON': 0.22, 'ETN': 0.22, 'VRTX': 0.21, 'PGR': 0.21, 'CRWD': 0.21,
            'DE': 0.21, 'PLD': 0.21, 'NEM': 0.2, 'BMY': 0.2, 'PH': 0.2,
            'BX': 0.2, 'CB': 0.2, 'ADP': 0.18, 'CEG': 0.18, 'MCK': 0.18,
            'CMCSA': 0.18, 'CVS': 0.18, 'LMT': 0.18, 'SBUX': 0.17, 'CME': 0.17,
            'SNPS': 0.17, 'SO': 0.17, 'TMUS': 0.16, 'ICE': 0.16, 'HOOD': 0.16,
            'MO': 0.16, 'DUK': 0.16, 'KKR': 0.16, 'MMC': 0.16, 'GD': 0.15,
            'CDNS': 0.15, 'MMM': 0.15, 'DASH': 0.15, 'USB': 0.15, 'HWM': 0.15,
            'PNC': 0.15, 'BK': 0.15, 'TT': 0.14, 'CRH': 0.14, 'REGN': 0.14,
            'MCO': 0.14, 'ELV': 0.14, 'WM': 0.14, 'EMR': 0.14, 'FCX': 0.14,
            'AMT': 0.14, 'TDG': 0.14, 'UPS': 0.14, 'NOC': 0.13, 'ORLY': 0.13,
            'RCL': 0.13, 'GM': 0.13, 'SHW': 0.13, 'EQIX': 0.13, 'NKE': 0.13,
            'AON': 0.13, 'HCA': 0.13, 'CMI': 0.13, 'CI': 0.13, 'MAR': 0.12,
            'WBD': 0.12, 'JCI': 0.12, 'GLW': 0.12, 'WDC': 0.12, 'ECL': 0.12,
            'HLT': 0.12, 'TEL': 0.12, 'STX': 0.12, 'APO': 0.12, 'FDX': 0.12,
            'MDLZ': 0.12, 'AJG': 0.12, 'COR': 0.11, 'CSX': 0.11, 'ITW': 0.11,
            'PWR': 0.11, 'TFC': 0.11, 'CVNA': 0.11, 'CTAS': 0.11, 'NSC': 0.11,
            'TRV': 0.11, 'MSI': 0.11, 'ADSK': 0.11, 'CL': 0.11, 'ROST': 0.11,
            'AEP': 0.11, 'PCAR': 0.11, 'NXPI': 0.1, 'SPG': 0.1, 'ABNB': 0.1,
            'APD': 0.1, 'BDX': 0.1, 'LHX': 0.1, 'IDXX': 0.1, 'SRE': 0.1,
            'COIN': 0.1, 'URI': 0.1, 'ZTS': 0.1, 'AZO': 0.1, 'PYPL': 0.1,
            'MNST': 0.09, 'ALL': 0.09, 'F': 0.09, 'O': 0.09, 'AFL': 0.09,
            'CMG': 0.09, 'FTNT': 0.09, 'DLR': 0.09, 'SNDK': 0.09, 'VST': 0.09,
            'EW': 0.09, 'AXON': 0.09, 'CAH': 0.09, 'CBRE': 0.08, 'D': 0.08,
            'AME': 0.08, 'ROP': 0.08, 'TGT': 0.08, 'FAST': 0.08, 'DAL': 0.08,
            'CTVA': 0.08, 'MPWR': 0.08, 'AMP': 0.08, 'DDOG': 0.08, 'ROK': 0.08,
            'EA': 0.08, 'WDAY': 0.08, 'NDAQ': 0.08, 'TTWO': 0.08, 'GWW': 0.08,
            'MSCI': 0.08, 'EXC': 0.08, 'XEL': 0.08, 'MET': 0.08, 'RSG': 0.07,
            'A': 0.07, 'PSA': 0.07, 'YUM': 0.07, 'AIG': 0.07, 'CARR': 0.07,
            'IQV': 0.07, 'PRU': 0.07, 'ETR': 0.07, 'EBAY': 0.07, 'CTSH': 0.07,
            'MCHP': 0.07, 'XYZ': 0.07, 'GEHC': 0.07, 'PEG': 0.07, 'VMC': 0.07,
            'DHI': 0.07, 'HIG': 0.07, 'UAL': 0.07, 'MLM': 0.07, 'NUE': 0.07,
            'STT': 0.06, 'CCI': 0.06, 'FISV': 0.06, 'KDP': 0.06, 'FICO': 0.06,
            'WAB': 0.06, 'FIX': 0.06, 'KEYS': 0.06, 'DELL': 0.06, 'PAYX': 0.06,
            'RMD': 0.06, 'KR': 0.06, 'ED': 0.06, 'VTR': 0.06, 'ARES': 0.06,
            'CCL': 0.06, 'EXPE': 0.06, 'TER': 0.06, 'FIS': 0.06, 'SYY': 0.06,
            'OTIS': 0.06, 'ACGL': 0.06, 'GRMN': 0.06, 'WEC': 0.06, 'PCG': 0.06,
            'CPRT': 0.06, 'XYL': 0.06, 'HUM': 0.06, 'FITB': 0.06, 'KMB': 0.06,
            'MTB': 0.06, 'KVUE': 0.06, 'IBKR': 0.06, 'WTW': 0.06, 'DG': 0.05,
            'SYF': 0.05, 'VRSK': 0.05, 'ODFL': 0.05, 'MTD': 0.05, 'HPE': 0.05,
            'VICI': 0.05, 'IR': 0.05, 'ULTA': 0.05, 'RJF': 0.05, 'EME': 0.05,
            'HBAN': 0.05, 'NRG': 0.05, 'EXR': 0.05, 'ADM': 0.05, 'DOV': 0.05,
            'BIIB': 0.05, 'DXCM': 0.05, 'NTRS': 0.05, 'AEE': 0.05, 'TPR': 0.05,
            'CBOE': 0.05, 'DTE': 0.05, 'HSY': 0.05, 'ATO': 0.05, 'TSCO': 0.05,
            'CFG': 0.05, 'CSGP': 0.05, 'EFX': 0.05, 'EL': 0.05, 'FSLR': 0.04,
            'IRM': 0.04, 'BR': 0.04, 'PPL': 0.04, 'AVB': 0.04, 'STE': 0.04,
            'CINF': 0.04, 'LDOS': 0.04, 'HUBB': 0.04, 'RF': 0.04, 'ON': 0.04,
            'DLTR': 0.04, 'VLTO': 0.04, 'AWK': 0.04, 'TDY': 0.04, 'OMC': 0.04,
            'CNP': 0.04, 'ES': 0.04, 'JBL': 0.04, 'WAT': 0.04, 'WSM': 0.04,
            'PPG': 0.04, 'DRI': 0.04, 'TROW': 0.04, 'BRO': 0.04, 'FE': 0.04,
            'STLD': 0.04, 'PHM': 0.04, 'GIS': 0.04, 'LULU': 0.04, 'LYV': 0.04,
            'EIX': 0.04, 'CPAY': 0.04, 'LEN': 0.04, 'LUV': 0.04, 'NVR': 0.04,
            'EQR': 0.04, 'CNC': 0.04, 'CMS': 0.04, 'EXPD': 0.04, 'LH': 0.04,
            'PODD': 0.04, 'PTC': 0.04, 'IP': 0.04, 'NTAP': 0.04, 'SW': 0.04,
            'WRB': 0.04, 'VRSN': 0.04, 'CHD': 0.04, 'WST': 0.03, 'DGX': 0.03,
            'STZ': 0.03, 'NI': 0.03, 'KEY': 0.03, 'CHRW': 0.03, 'HPQ': 0.03,
            'KHC': 0.03, 'AMCR': 0.03, 'SBAC': 0.03, 'TYL': 0.03, 'TRMB': 0.03,
            'ALB': 0.03, 'Q': 0.03, 'LVS': 0.03, 'PKG': 0.03, 'ZBRA': 0.03,
            'MRNA': 0.02, 'SOLV': 0.02, 'CLX': 0.02, 'IVZ': 0.02, 'SWK': 0.02,
            'CF': 0.02, 'EPAM': 0.02, 'AIZ': 0.02, 'DOC': 0.02, 'RVTY': 0.02,
            'HAS': 0.02, 'BLDR': 0.02, 'LYB': 0.02, 'CPT': 0.02, 'REG': 0.02,
            'UHS': 0.02, 'HST': 0.02, 'ALGN': 0.02, 'GL': 0.02, 'NCLH': 0.02,
            'DAY': 0.02, 'UDR': 0.02, 'FDS': 0.02, 'CRL': 0.02, 'PNW': 0.02,
            'BAX': 0.02, 'AES': 0.02, 'SJM': 0.02, 'TECH': 0.02, 'FOX': 0.02,
            'NWSA': 0.02, 'WYNN': 0.02, 'BXP': 0.02, 'MOH': 0.02, 'SWKS': 0.02,
            'GNRC': 0.01, 'ARE': 0.01, 'MOS': 0.01, 'FRT': 0.01, 'HSIC': 0.01,
            'TAP': 0.01, 'BEN': 0.01, 'CAG': 0.01, 'PAYC': 0.01, 'POOL': 0.01,
            'MTCH': 0.01, 'AOS': 0.01, 'ERIE': 0.01, 'MGM': 0.01, 'HRL': 0.01,
            'LW': 0.01, 'CPB': 0.01, 'BF.B': 0.01, 'DVA': 0.01, 'PSKY': 0.01,
            'NWS': 0.01
        };

        // SPX weights - For now using SPXE as approximation
        // TODO: Load actual SPX weights from separate file
        const spxApproximateWeights = { ...spxeWeights };

        // Fetch SPY/SPX constituent weights
        async function fetchSPYWeights() {
            // Return SPX approximate weights (currently using SPXE as proxy)
            // TODO: Load actual SPX weights with Energy sector included
            return { ...spxApproximateWeights };
        }

        // Fetch SPXE weights (S&P 500 ex-Energy)
        async function fetchSPYWeightsExcludingEnergy() {
            // Return the actual SPXE weights from CSV file
            return { ...spxeWeights };
        }

        // Calculate tracking error
        async function calculateTrackingError() {
            // Aggregate holdings from all sleeves
            const aggregatedHoldings = aggregatePortfolioHoldings();

            if (!aggregatedHoldings) {
                // Error messages handled in aggregatePortfolioHoldings()
                return;
            }

            if (aggregatedHoldings.length === 0) {
                alert('Please add at least one holding to any sleeve');
                return;
            }

            // Show loading, hide error and results
            document.getElementById('loading').style.display = 'block';
            document.getElementById('error').style.display = 'none';
            document.getElementById('results').style.display = 'none';

            try {
                // Get parameters
                const benchmark = document.getElementById('benchmark').value;
                const period = document.getElementById('period').value;
                const frequency = document.getElementById('frequency').value;

                // Fetch benchmark weights
                console.log('Fetching benchmark weights...');
                benchmarkWeights = await fetchBenchmarkWeights(benchmark);
                console.log('Benchmark weights loaded:', Object.keys(benchmarkWeights).length, 'constituents');

                // Use traditional approach with OTHER_SPXE (no look-through)
                // Index funds like VOO and SPXE can be treated as single holdings just like individual stocks
                console.log('Using traditional tracking error approach...');
                const results = await fetchDataAndCalculate(aggregatedHoldings, benchmark, period, frequency, false); // false = create OTHER_SPXE

                // store for export
                lastResults = results;

                // Display results
                displayResults(results);

                document.getElementById('loading').style.display = 'none';
                document.getElementById('results').style.display = 'block';

            } catch (error) {
                console.error('Error:', error);
                document.getElementById('error').textContent = 'Error: ' + error.message;
                document.getElementById('error').style.display = 'block';
                document.getElementById('loading').style.display = 'none';
            }
        }

        // Fetch data and perform calculations
        async function fetchDataAndCalculate(holdings, benchmark, period, frequency, skipBenchmarkRemainder = false) {
            // Determine which tickers we need - all actual holdings
            let tickersToFetch = [...holdings.map(h => h.ticker)];

            // Add benchmark ticker
            if (benchmark === '^GSPC') {
                // For SPX, try ^GSPC first, fallback to SPY
                tickersToFetch.push('^GSPC', 'SPY');
                console.log('Fetching ^GSPC with SPY as fallback');
            } else {
                tickersToFetch.push(benchmark);
            }

            // Remove duplicates
            const tickers = [...new Set(tickersToFetch)];
            console.log(`Total tickers to fetch: ${tickers.length} (portfolio holdings + benchmark)`);

            // Fetch price data
            const priceData = await fetchPriceData(tickers, period, frequency);
            console.log('Price data keys:', Object.keys(priceData).slice(0, 10));

            // Calculate returns (log returns)
            const returns = calculateReturns(priceData);
            console.log('Returns keys:', Object.keys(returns).slice(0, 10));

            // Get benchmark returns and timestamps
            let benchmarkReturns;
            let benchmarkTimestamps;
            if (benchmark === '^GSPC') {
                // For SPX, try ^GSPC first, fallback to SPY
                benchmarkReturns = returns['^GSPC'];
                const benchData = priceData['^GSPC'];
                benchmarkTimestamps = benchData ? (Array.isArray(benchData) ? [] : benchData.timestamps) : [];

                if (!benchmarkReturns || benchmarkReturns.length === 0) {
                    console.warn('^GSPC data not available, using SPY as fallback...');
                    benchmarkReturns = returns['SPY'];
                    const spyData = priceData['SPY'];
                    benchmarkTimestamps = spyData ? (Array.isArray(spyData) ? [] : spyData.timestamps) : [];
                    console.log('Using SPY as SPX proxy');
                }
            } else {
                benchmarkReturns = returns[benchmark];
                const benchData = priceData[benchmark];
                benchmarkTimestamps = benchData ? (Array.isArray(benchData) ? [] : benchData.timestamps) : [];
            }

            // Validate benchmark returns
            if (!benchmarkReturns || benchmarkReturns.length === 0) {
                throw new Error(`Failed to calculate benchmark returns for ${benchmark}. Please check that the benchmark data is available.`);
            }
            console.log(`Benchmark returns calculated: ${benchmarkReturns.length} periods`);

            // Filter out holdings we don't have price data for
            const holdingsWithData = holdings.filter(h => {
                const hasData = returns[h.ticker] && returns[h.ticker].length > 0;
                if (!hasData) {
                    console.warn(`Skipping ${h.ticker} - no price data available`);
                }
                return hasData;
            });

            if (holdingsWithData.length === 0) {
                throw new Error('No valid price data for any holdings');
            }

            console.log(`Processing ${holdingsWithData.length}/${holdings.length} holdings with valid price data`);

            // Normalize portfolio weights
            const totalWeight = holdingsWithData.reduce((sum, h) => sum + h.weight, 0);
            const normalizedHoldings = holdingsWithData.map(h => ({
                ...h,
                weight: h.weight / totalWeight * 100
            }));

            // ===== ADD BENCHMARK REMAINDER POSITION (unless skipped for look-through) =====
            if (!skipBenchmarkRemainder) {
                // Calculate covered benchmark weight (only for real constituents, not index funds)
                let coveredBmkPct = 0;
                normalizedHoldings.forEach(holding => {
                    if (!holding.isIndexFund) {
                        const bmkWeight = benchmarkWeights[holding.ticker] || 0;
                        if (bmkWeight > 0) {
                            coveredBmkPct += bmkWeight;
                        }
                    }
                });

                const otherBmkPct = Math.max(0, 100 - coveredBmkPct);
                console.log(`Covered benchmark weight: ${coveredBmkPct.toFixed(2)}%, Other: ${otherBmkPct.toFixed(2)}%`);

                // If there's a remainder, create synthetic OTHER position
                if (otherBmkPct > 0.0001) {
                    const otherTicker = benchmark === 'SPXE' ? 'OTHER_SPXE' : 'OTHER_SPX';

                    // Calculate daily return series for OTHER so benchmark return identity holds
                    // Formula: otherReturn = (benchmarkReturn - SUMPRODUCT(bmkWeights, returns)) / otherBmkWeight
                    const otherReturns = [];
                    for (let i = 0; i < benchmarkReturns.length; i++) {
                        // Calculate known part: sum of (benchmark_weight Ã— actual_return) for ALL holdings
                        let knownPart = 0;
                        normalizedHoldings.forEach(holding => {
                            if (!holding.isIndexFund) {
                                const bmkWeight = benchmarkWeights[holding.ticker] || 0;
                                const tickerReturns = returns[holding.ticker];
                                if (tickerReturns) {
                                    knownPart += (bmkWeight / 100) * tickerReturns[i];
                                }
                            }
                        });

                        // Solve for OTHER return
                        const otherRet = (benchmarkReturns[i] - knownPart) / (otherBmkPct / 100);
                        otherReturns.push(otherRet);
                    }

                    // Add OTHER to returns dictionary
                    returns[otherTicker] = otherReturns;

                    // Create synthetic price series for OTHER
                    const otherPrices = [100];
                    for (let i = 0; i < otherReturns.length; i++) {
                        otherPrices.push(otherPrices[otherPrices.length - 1] * Math.exp(otherReturns[i]));
                    }
                    // Store in same format as other tickers (with empty timestamps)
                    priceData[otherTicker] = { prices: otherPrices, timestamps: [] };

                    // Add OTHER holding to normalizedHoldings
                    normalizedHoldings.push({
                        ticker: otherTicker,
                        weight: 0, // portfolio weight is 0%
                        sector: 'Other',
                        sleeve: 'Benchmark Remainder',
                        isBenchmarkRemainder: true,
                        isIndexFund: false
                    });

                    // Add OTHER to benchmarkWeights
                    benchmarkWeights[otherTicker] = otherBmkPct;

                    console.log(`Created ${otherTicker} with benchmark weight ${otherBmkPct.toFixed(2)}%`);
                }
            } else {
                console.log(`Skipping benchmark remainder creation (using look-through approach)`);
            }
            // ===== END BENCHMARK REMAINDER =====

            // Calculate active returns and weighted active returns for each equity
            const activeReturns = {};
            const weightedActiveReturns = {};

            normalizedHoldings.forEach(holding => {
                const ticker = holding.ticker;

                console.log(`Processing ${ticker}: isIndexFund=${holding.isIndexFund}, weight=${holding.weight.toFixed(2)}%`);

                // Special handling for index funds - use actual fund returns vs benchmark
                if (holding.isIndexFund) {
                    console.log(`  -> Using index fund logic for ${ticker}`);
                    const fundWeight = holding.weight / 100; // Convert to decimal
                    const fundReturns = returns[ticker];

                    // Validate that we have returns data for this fund
                    if (!fundReturns || fundReturns.length === 0) {
                        console.error(`Missing price data for index fund ${ticker}!`);
                        throw new Error(`Missing price data for ${ticker}. Please check that the ticker is valid and try again.`);
                    }

                    console.log(`  -> ${ticker} returns sample:`, fundReturns.slice(0, 3));
                    console.log(`  -> Benchmark returns sample:`, benchmarkReturns.slice(0, 3));

                    // Active returns for index fund: fund return - benchmark return
                    activeReturns[ticker] = fundReturns.map((ret, i) => ret - benchmarkReturns[i]);

                    console.log(`  -> Active returns sample for ${ticker}:`, activeReturns[ticker].slice(0, 3));

                    // Weighted active returns: fund weight * active returns
                    weightedActiveReturns[ticker] = activeReturns[ticker].map(ret => fundWeight * ret);
                } else {
                    // Regular stock handling - uses active weight
                    const benchmarkWeight = benchmarkWeights[ticker] || 0;
                    const activeWeightPct = holding.weight - benchmarkWeight;
                    const activeWeight = activeWeightPct / 100; // Convert to decimal

                    // Special case: if ticker matches benchmark, use benchmark returns directly
                    let tickerReturns;
                    if (ticker === benchmark || (benchmark === 'SPXE' && ticker === 'SPXE')) {
                        tickerReturns = benchmarkReturns;
                    } else {
                        tickerReturns = returns[ticker];
                    }

                    // Validate that we have returns data for this ticker
                    if (!tickerReturns || tickerReturns.length === 0) {
                        console.error(`Missing returns for ${ticker}`);
                        console.error(`Available tickers:`, Object.keys(returns).filter(t => t.includes('BRK')));
                        throw new Error(`Missing price data for ${ticker}. Please check that the ticker is valid.`);
                    }

                    // Active returns: stock return - benchmark return
                    activeReturns[ticker] = tickerReturns.map((ret, i) => ret - benchmarkReturns[i]);

                    // Weighted active returns: active weight * active returns
                    weightedActiveReturns[ticker] = activeReturns[ticker].map(ret => activeWeight * ret);
                }
            });

            // Calculate portfolio active returns = sum of weighted active returns
            const numPeriods = benchmarkReturns.length;
            const portfolioActiveReturns = [];
            for (let i = 0; i < numPeriods; i++) {
                let sumWeightedActiveReturns = 0;
                normalizedHoldings.forEach(holding => {
                    sumWeightedActiveReturns += weightedActiveReturns[holding.ticker][i];
                });
                portfolioActiveReturns.push(sumWeightedActiveReturns);
            }

            // Calculate portfolio tracking error (annualized)
            const portfolioTE = standardDeviation(portfolioActiveReturns) * Math.sqrt(252);

            // Calculate portfolio *active* return (annualized, portfolio return minus benchmark return)
            // Uses log returns, consistent with the rest of the calculations.
            const portfolioReturnSeries = [];
            for (let i = 0; i < numPeriods; i++) {
                let pr = 0;
                normalizedHoldings.forEach(holding => {
                    const w = holding.weight / 100;
                    const ticker = holding.ticker;
                    // Use benchmark returns if ticker matches benchmark
                    const tickerReturns = (ticker === benchmark || (benchmark === 'SPXE' && ticker === 'SPXE'))
                        ? benchmarkReturns
                        : returns[ticker];
                    pr += w * tickerReturns[i];
                });
                portfolioReturnSeries.push(pr);
            }

            const portfolioActiveReturnSeries = portfolioReturnSeries.map((pr, i) => pr - benchmarkReturns[i]);
            const portfolioActiveCumulativeReturn = portfolioActiveReturnSeries.reduce((acc, r) => acc + r, 0);
            const portfolioAnnualizationFactor = 252 / portfolioActiveReturnSeries.length;
            const portfolioAnnualizedActiveReturnPct = portfolioActiveCumulativeReturn * portfolioAnnualizationFactor * 100;

            // Calculate benchmark annualized return
            const benchmarkCumulativeReturn = benchmarkReturns.reduce((acc, ret) => acc + ret, 0);
            const benchmarkAnnualizationFactor = 252 / benchmarkReturns.length;
            const benchmarkAnnualizedReturn = benchmarkCumulativeReturn * benchmarkAnnualizationFactor * 100; // Convert to percentage

            // Calculate total return for each equity (annualized)
            const equityTotalReturns = {};
            const equityPrices = {};
            normalizedHoldings.forEach(holding => {
                const ticker = holding.ticker;

                // Special case: if the ticker matches the benchmark, use benchmark returns directly
                let tickerReturns;
                let prices;
                if (ticker === benchmark || (benchmark === 'SPXE' && ticker === 'SPXE')) {
                    tickerReturns = benchmarkReturns;
                    const data = priceData[ticker] || { prices: [100, 100], timestamps: [] };
                    prices = Array.isArray(data) ? data : data.prices;
                } else {
                    tickerReturns = returns[ticker];
                    const data = priceData[ticker];
                    prices = Array.isArray(data) ? data : data.prices;
                }

                // Calculate cumulative return over the period
                const cumulativeReturn = tickerReturns.reduce((acc, ret) => acc + ret, 0);

                // Annualize based on the number of periods
                const annualizationFactor = 252 / tickerReturns.length;
                const annualizedReturn = cumulativeReturn * annualizationFactor;

                equityTotalReturns[ticker] = annualizedReturn * 100; // Convert to percentage

                // Capture start and end prices
                equityPrices[ticker] = {
                    startPrice: prices[0],
                    endPrice: prices[prices.length - 1]
                };
            });

            // ===== PROPER MATRIX APPROACH FOR CTE CALCULATION =====
            // Step 1: Build covariance matrix of RAW returns (not active returns!)
            // The active weights will account for the benchmark positioning
            // Include ALL holdings (including index funds) in the matrix
            const holdingTickers = normalizedHoldings.map(h => h.ticker);
            const n = holdingTickers.length;
            const covMatrix = [];

            for (let i = 0; i < n; i++) {
                covMatrix[i] = [];
                for (let j = 0; j < n; j++) {
                    const tickerI = holdingTickers[i];
                    const tickerJ = holdingTickers[j];

                    // Get RAW returns for each ticker (not active returns)
                    const returnsI = (tickerI === benchmark || (benchmark === 'SPXE' && tickerI === 'SPXE'))
                        ? benchmarkReturns
                        : returns[tickerI];
                    const returnsJ = (tickerJ === benchmark || (benchmark === 'SPXE' && tickerJ === 'SPXE'))
                        ? benchmarkReturns
                        : returns[tickerJ];

                    // Covariance of RAW returns (matches Excel approach)
                    covMatrix[i][j] = calculateCovariance(returnsI, returnsJ);
                }
            }

            // Step 2: Get active weights as decimal (not percentage) - for ALL holdings
            const activeWeightsDecimal = normalizedHoldings.map(holding => {
                const portfolioWeight = holding.weight; // Percentage

                // For index funds, benchmark weight = 0 (they're not benchmark constituents)
                let benchmarkWeight = benchmarkWeights[holding.ticker] || 0;

                return (portfolioWeight - benchmarkWeight) / 100; // Convert to decimal
            });

            // Step 3: Calculate Sigma vector = Covariance Matrix Ã— Active Weights Vector
            const sigmaVector = [];
            for (let i = 0; i < n; i++) {
                let sigma_i = 0;
                for (let j = 0; j < n; j++) {
                    sigma_i += covMatrix[i][j] * activeWeightsDecimal[j];
                }
                sigmaVector[i] = sigma_i;
            }

            // Step 4: Calculate daily TE^2 = active_weights^T Ã— Sigma
            let dailyTEsquared = 0;
            for (let i = 0; i < n; i++) {
                dailyTEsquared += activeWeightsDecimal[i] * sigmaVector[i];
            }

            // Step 5: Annualize TE
            const dailyTE = Math.sqrt(dailyTEsquared);
            const annualizedTE = dailyTE * Math.sqrt(252);

            console.log(`Matrix-based TE calculation: Daily TE = ${dailyTE.toFixed(6)}, Annualized TE = ${(annualizedTE * 100).toFixed(2)}%`);
            console.log(`Original TE calculation: ${(portfolioTE * 100).toFixed(2)}%`);

            // Use the matrix-based TE for MCTE/CTE calculations
            const portfolioTEtoUse = annualizedTE;

            // ===== CALCULATE PORTFOLIO BETA =====
            // Beta = Cov(Portfolio, Benchmark) / Var(Benchmark)
            // Using component weights: Beta_p = sum(w_i Ã— Beta_i), where Beta_i = Cov(Stock_i, Benchmark) / Var(Benchmark)

            // Calculate variance of benchmark returns
            const benchmarkVariance = calculateCovariance(benchmarkReturns, benchmarkReturns);

            // Calculate portfolio beta using component weights
            let portfolioBeta = 0;
            for (let i = 0; i < n; i++) {
                const ticker = holdingTickers[i];
                const portfolioWeight = normalizedHoldings[i].weight / 100; // Convert to decimal

                // Get RAW returns for this ticker
                const tickerReturns = (ticker === benchmark || (benchmark === 'SPXE' && ticker === 'SPXE'))
                    ? benchmarkReturns
                    : returns[ticker];

                // Calculate Beta_i = Cov(Stock_i, Benchmark) / Var(Benchmark)
                const covWithBenchmark = calculateCovariance(tickerReturns, benchmarkReturns);
                const beta_i = benchmarkVariance !== 0 ? covWithBenchmark / benchmarkVariance : 1.0;

                // Add weighted contribution to portfolio beta
                portfolioBeta += portfolioWeight * beta_i;
            }

            console.log(`\n===== Portfolio Beta Calculation =====`);
            console.log(`Benchmark Variance: ${benchmarkVariance.toFixed(8)}`);
            console.log(`Portfolio Beta: ${portfolioBeta.toFixed(4)}`);

            // ===== RETURN DECOMPOSITION (CAPM/Jensen's Alpha) =====
            // This decomposition answers: "After accounting for Beta exposure, did I beat the market?"
            //
            // Total Portfolio Return = Beta Return + Alpha (Residual)
            // Where:
            //   Beta Return = Beta Ã— Benchmark Return (return from market exposure)
            //   Alpha = Total Return - Beta Return (true stock-picking skill)
            //
            // Example: If portfolio returned 23.59%, benchmark 14.29%, and Beta is 1.278:
            //   Beta Return = 1.278 Ã— 14.29% = 18.25%
            //   Alpha = 23.59% - 18.25% = 5.34%
            //
            // This shows that while you "beat" the benchmark by 9.30%, about 4% of that
            // was just from having higher Beta (riding the market wave). Your actual
            // stock-picking skill (Alpha) was 5.34%.

            const betaReturn = portfolioBeta * benchmarkAnnualizedReturn; // Return from market exposure
            const portfolioTotalReturn = portfolioAnnualizedActiveReturnPct + benchmarkAnnualizedReturn;
            const alpha = portfolioTotalReturn - betaReturn; // Jensen's Alpha (residual after Beta exposure)

            console.log(`\n===== Return Decomposition (CAPM/Jensen's Alpha) =====`);
            console.log(`Total Portfolio Return: ${portfolioTotalReturn.toFixed(2)}%`);
            console.log(`Benchmark Return: ${benchmarkAnnualizedReturn.toFixed(2)}%`);
            console.log(`Portfolio Beta: ${portfolioBeta.toFixed(3)}`);
            console.log(`Beta Return (Market Exposure): ${betaReturn.toFixed(2)}%`);
            console.log(`Alpha (True Skill/Residual): ${alpha.toFixed(2)}%`);
            console.log(`Active Return (Portfolio - Benchmark): ${portfolioAnnualizedActiveReturnPct.toFixed(2)}%`);

            // Step 6: Calculate MCTE and CTE for each equity
            console.log('\n===== MCTE/CTE Calculation Details =====');
            console.log(`Annualized TE: ${(portfolioTEtoUse * 100).toFixed(4)}%`);
            console.log(`Number of holdings in matrix: ${holdingTickers.length}`);

            const equityResults = normalizedHoldings.map((holding, i) => {
                const ticker = holding.ticker;
                const portfolioWeight = holding.weight; // Percentage

                // For index funds, benchmark weight = 0 (they're not benchmark constituents)
                let benchmarkWeight = benchmarkWeights[ticker] || 0;

                const activeWeightPct = portfolioWeight - benchmarkWeight; // Percentage
                const activeWeight = activeWeightPct / 100; // Decimal

                // Use matrix approach for ALL holdings (including index funds)
                const dailySigma_i = sigmaVector[i];
                // CRITICAL FIX: Sigma has units of variance (returnÂ²), so annualize by Ã— 252, NOT Ã— âˆš252
                const annualizedSigma_i = dailySigma_i * 252;

                // MCTE_i = Sigma_i / TE (both annualized)
                const mcte = portfolioTEtoUse !== 0 ? annualizedSigma_i / portfolioTEtoUse : 0;

                // CTE_i = MCTE_i Ã— active_weight_i
                const cte = mcte * activeWeight;

                // Log first 3 equities for debugging
                if (i < 3 || holding.isIndexFund) {
                    console.log(`\n${ticker}${holding.isIndexFund ? ' (INDEX FUND)' : ''}:`);
                    console.log(`  Active Weight: ${activeWeightPct.toFixed(4)}% (${activeWeight.toFixed(6)} decimal)`);
                    console.log(`  Daily Sigma_i: ${dailySigma_i.toFixed(8)}`);
                    console.log(`  Annualized Sigma_i: ${annualizedSigma_i.toFixed(8)}`);
                    console.log(`  MCTE: ${(mcte * 100).toFixed(4)}%`);
                    console.log(`  CTE: ${(cte * 100).toFixed(4)}%`);
                }

                // Calculate active return (equity return - benchmark return)
                const activeReturn = equityTotalReturns[ticker] - benchmarkAnnualizedReturn;

                // Calculate contribution to portfolio active return (weight * active return)
                const contributionToReturn = (portfolioWeight / 100) * activeReturn;

                const ctePercent = cte * 100;

                return {
                    ticker,
                    sector: holding.sector,
                    sleeve: holding.sleeve || 'Managed Core',
                    portfolioWeight: portfolioWeight,
                    benchmarkWeight: benchmarkWeight,
                    activeWeight: activeWeightPct,
                    return: equityTotalReturns[ticker], // Annualized return
                    activeReturn: activeReturn, // Active return vs benchmark
                    contributionToReturn: contributionToReturn, // Contribution to portfolio active return
                    mcte: mcte * 100, // Convert to percentage
                    cte: ctePercent // Convert to percentage
                };
            });

            // Aggregate by sector
            const sectorResults = aggregateBySector(equityResults);

            // Calculate totals for percentage contributions
            const totalCTE = equityResults.reduce((sum, eq) => sum + eq.cte, 0);
            const totalContributionToReturn = equityResults.reduce((sum, eq) => sum + eq.contributionToReturn, 0);

            // Add percentage fields to each equity
            equityResults.forEach(eq => {
                eq.pctOfReturn = totalContributionToReturn !== 0 ? (eq.contributionToReturn / totalContributionToReturn) * 100 : 0;
                eq.pctOfTE = totalCTE !== 0 ? (eq.cte / totalCTE) * 100 : 0;
            });

            // Verification
            const difference = Math.abs(totalCTE - portfolioTEtoUse * 100);
            const percentError = (difference / (portfolioTEtoUse * 100)) * 100;

            const verification = {
                sumOfCTE: totalCTE,
                portfolioTE: portfolioTEtoUse * 100,
                difference: difference,
                percentError: percentError,
                verified: difference < 0.1, // More lenient threshold (0.1% instead of 0.01%)
                benchmark: benchmark
            };

            // Note: portfolioTotalReturn and alpha are already calculated above in the decomposition section

            // Calculate Information Ratio (Alpha / TE)
            // This is the ultimate performance score: risk-adjusted alpha per unit of tracking error
            const informationRatio = portfolioTEtoUse !== 0 ? alpha / (portfolioTEtoUse * 100) : 0;

            // ===== CALCULATE ROLLING METRICS (60-DAY WINDOW) =====
            const rollingBetaSeries = [];
            const rollingTESeries = [];
            const rollingWindow = 60; // 60 trading days (~3 months)

            for (let i = rollingWindow - 1; i < portfolioReturnSeries.length; i++) {
                const windowPortfolioReturns = portfolioReturnSeries.slice(i - rollingWindow + 1, i + 1);
                const windowBenchmarkReturns = benchmarkReturns.slice(i - rollingWindow + 1, i + 1);

                // Calculate covariance and variance for this window
                const windowCov = calculateCovariance(windowPortfolioReturns, windowBenchmarkReturns);
                const windowBenchmarkVar = calculateCovariance(windowBenchmarkReturns, windowBenchmarkReturns);

                // Beta = Cov(Portfolio, Benchmark) / Var(Benchmark)
                const windowBeta = windowBenchmarkVar !== 0 ? windowCov / windowBenchmarkVar : 1.0;
                rollingBetaSeries.push(windowBeta);

                // Calculate rolling TE: standard deviation of active returns in this window
                const windowActiveReturns = windowPortfolioReturns.map((pr, j) => pr - windowBenchmarkReturns[j]);
                const windowTE = standardDeviation(windowActiveReturns);
                const annualizedWindowTE = windowTE * Math.sqrt(252); // Annualize
                rollingTESeries.push(annualizedWindowTE * 100); // Convert to percentage
            }

            console.log(`\n===== Rolling Metrics Statistics =====`);
            console.log(`Number of rolling observations: ${rollingBetaSeries.length}`);
            if (rollingBetaSeries.length > 0) {
                const avgBeta = rollingBetaSeries.reduce((sum, b) => sum + b, 0) / rollingBetaSeries.length;
                const minBeta = Math.min(...rollingBetaSeries);
                const maxBeta = Math.max(...rollingBetaSeries);
                console.log(`Average Rolling Beta: ${avgBeta.toFixed(3)}`);
                console.log(`Min Rolling Beta: ${minBeta.toFixed(3)}`);
                console.log(`Max Rolling Beta: ${maxBeta.toFixed(3)}`);

                const avgTE = rollingTESeries.reduce((sum, te) => sum + te, 0) / rollingTESeries.length;
                const minTE = Math.min(...rollingTESeries);
                const maxTE = Math.max(...rollingTESeries);
                console.log(`Average Rolling TE: ${avgTE.toFixed(2)}%`);
                console.log(`Min Rolling TE: ${minTE.toFixed(2)}%`);
                console.log(`Max Rolling TE: ${maxTE.toFixed(2)}%`);
            }

            return {
                portfolioTE: portfolioTEtoUse * 100,
                portfolioActiveReturn: portfolioAnnualizedActiveReturnPct, // Portfolio Return - Benchmark Return
                portfolioTotalReturn: portfolioTotalReturn,
                benchmarkReturn: benchmarkAnnualizedReturn,
                portfolioBeta: portfolioBeta,
                betaReturn: betaReturn,
                alpha: alpha, // Jensen's Alpha (Total Return - Beta Return)
                informationRatio: informationRatio,
                // (kept for backward compatibility if anything else relies on it)
                portfolioReturn: portfolioAnnualizedActiveReturnPct,
                equityResults,
                sectorResults,
                verification,
                numHoldings: holdings.length,
                period,
                benchmark,
                series: {
                    portfolioReturnSeries,
                    portfolioActiveReturnSeries,
                    benchmarkReturns,
                    weightedActiveReturns,
                    priceData,
                    rollingBetaSeries,
                    rollingTESeries,
                    timestamps: benchmarkTimestamps
                }
            };
        }

        // Map ticker symbols to Yahoo Finance format
        function mapTickerForYahoo(ticker) {
            // Yahoo Finance uses different formats for some tickers
            const tickerMap = {
                'BRK.B': 'BRK-B',
                'BF.B': 'BF-B'
            };
            return tickerMap[ticker] || ticker;
        }

        // Fetch price data using proxy server
        // Normalize ticker symbols for Yahoo Finance API
        function normalizeTickerForYahoo(ticker) {
            // Convert slash to hyphen (e.g., BRK/B -> BRK-B)
            let normalized = ticker.replace(/\//g, '-');

            // Convert dot to hyphen (e.g., BRK.B -> BRK-B)
            normalized = normalized.replace(/\./g, '-');

            return normalized;
        }

        async function fetchPriceData(tickers, period, frequency) {
            // PROXY SERVER URL - Vercel deployment
            // For local testing: 'http://localhost:3000'
            // For production: Use Vercel URL
            const PROXY_URL = 'https://tracking-error-proxy.vercel.app';

            const priceData = {};

            // Create mapping of normalized tickers to original tickers
            const tickerMapping = {};
            const normalizedTickers = tickers.map(ticker => {
                const normalized = normalizeTickerForYahoo(ticker);
                tickerMapping[normalized] = ticker;
                return normalized;
            });

            // Calculate date range
            let endDate = new Date();
            let startDate = new Date();

            if (period === 'custom') {
                const startInput = document.getElementById('startDate').value;
                const endInput = document.getElementById('endDate').value;

                if (!startInput || !endInput) {
                    throw new Error('Please select both start and end dates for custom range');
                }

                startDate = new Date(startInput);
                endDate = new Date(endInput);

                if (startDate >= endDate) {
                    throw new Error('Start date must be before end date');
                }
            } else if (period === '3mo') {
                startDate.setMonth(startDate.getMonth() - 3);
            } else if (period === '1y') {
                startDate.setFullYear(startDate.getFullYear() - 1);
            } else if (period === '3y') {
                startDate.setFullYear(startDate.getFullYear() - 3);
            }

            // Format dates for Polygon (YYYY-MM-DD)
            const formatDate = (date) => date.toISOString().split('T')[0];
            const fromDate = formatDate(startDate);
            const toDate = formatDate(endDate);

            // Map frequency to Polygon timespan
            const timespanMap = { '1d': 'day', '1wk': 'week', '1mo': 'month' };
            const timespan = timespanMap[frequency] || 'day';

            const failedTickers = [];

            console.log(`Fetching ${normalizedTickers.length} tickers via proxy server...`);

            // Paid tier: No client-side delays needed (proxy handles rate limiting)
            // Use Promise.all for parallel requests to maximize speed
            const fetchPromises = normalizedTickers.map(async (normalizedTicker, i) => {
                const originalTicker = tickerMapping[normalizedTicker];
                try {
                    console.log(`[${i + 1}/${normalizedTickers.length}] Fetching ${originalTicker} (as ${normalizedTicker})...`);

                    // Call proxy server endpoint with normalized ticker
                    const proxyUrl = `${PROXY_URL}/api/polygon?ticker=${normalizedTicker}&timespan=${timespan}&from=${fromDate}&to=${toDate}`;

                    const response = await fetch(proxyUrl);

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(errorData.error || `Proxy returned ${response.status}`);
                    }

                    const data = await response.json();

                    if (data.results && data.results.length > 0) {
                        // Extract closing prices and timestamps, store under ORIGINAL ticker
                        const prices = data.results.map(bar => bar.c);
                        const timestamps = data.results.map(bar => bar.t);
                        priceData[originalTicker] = { prices, timestamps };
                        console.log(`âœ“ ${originalTicker}: ${prices.length} data points`);
                    } else {
                        console.warn(`No data for ${originalTicker}`);
                        failedTickers.push(originalTicker);
                    }

                } catch (error) {
                    console.error(`Failed to fetch ${originalTicker}: ${error.message}`);
                    failedTickers.push(originalTicker);
                }
            });

            // Wait for all requests to complete
            await Promise.all(fetchPromises);

            if (failedTickers.length > 0) {
                console.warn(`Failed to fetch ${failedTickers.length} tickers:`, failedTickers.slice(0, 10).join(', '), failedTickers.length > 10 ? '...' : '');
            }

            console.log(`Successfully fetched ${Object.keys(priceData).length}/${tickers.length} tickers`);

            if (Object.keys(priceData).length === 0) {
                throw new Error('Failed to fetch any price data. Make sure the proxy server is running.');
            }

            return priceData;
        }

        // Calculate log returns
        function calculateReturns(priceData) {
            const returns = {};

            for (const [ticker, data] of Object.entries(priceData)) {
                // Handle both old format (array) and new format ({prices, timestamps})
                const prices = Array.isArray(data) ? data : data.prices;
                returns[ticker] = [];
                for (let i = 1; i < prices.length; i++) {
                    returns[ticker].push(Math.log(prices[i] / prices[i - 1]));
                }
            }

            return returns;
        }

        // Calculate SPXE returns as weighted average of constituents
        function calculateSPXEReturns(returns, weights) {
            // Get list of tickers that have both returns and weights
            const constituents = Object.keys(weights).filter(ticker => returns[ticker]);

            if (constituents.length === 0) {
                throw new Error('No constituent data available for SPXE calculation');
            }

            // Get the number of periods
            const numPeriods = returns[constituents[0]].length;

            // Calculate weighted return for each period
            const spxeReturns = [];
            for (let i = 0; i < numPeriods; i++) {
                let weightedReturn = 0;

                constituents.forEach(ticker => {
                    if (returns[ticker] && returns[ticker][i] !== undefined) {
                        const weight = weights[ticker] / 100; // Convert percentage to decimal
                        weightedReturn += weight * returns[ticker][i];
                    }
                });

                // Don't normalize - missing constituents just contribute 0
                // The weights already sum to ~100%, so this gives the correct index return
                spxeReturns.push(weightedReturn);
            }

            return spxeReturns;
        }

        // Calculate standard deviation (sample standard deviation, divide by n-1)
        function standardDeviation(values) {
            const n = values.length;
            if (n <= 1) return 0;
            const mean = values.reduce((sum, val) => sum + val, 0) / n;
            const squaredDiffs = values.map(val => Math.pow(val - mean, 2));
            const variance = squaredDiffs.reduce((sum, val) => sum + val, 0) / (n - 1);
            return Math.sqrt(variance);
        }

        // Calculate covariance (sample covariance, divide by n-1)
        function calculateCovariance(x, y) {
            const n = x.length;
            if (n <= 1) return 0;
            const meanX = x.reduce((sum, val) => sum + val, 0) / n;
            const meanY = y.reduce((sum, val) => sum + val, 0) / n;

            let covariance = 0;
            for (let i = 0; i < n; i++) {
                covariance += (x[i] - meanX) * (y[i] - meanY);
            }

            return covariance / (n - 1);
        }

        // Calculate R-squared for regression
        function calculateRSquared(portfolioReturns, benchmarkReturns, beta) {
            const n = portfolioReturns.length;
            if (n <= 1) return 0;

            // Calculate mean of portfolio returns
            const meanY = portfolioReturns.reduce((sum, val) => sum + val, 0) / n;

            // Calculate total sum of squares (TSS) and residual sum of squares (RSS)
            let tss = 0;
            let rss = 0;
            for (let i = 0; i < n; i++) {
                const predicted = beta * benchmarkReturns[i]; // y = beta * x (no intercept)
                const actual = portfolioReturns[i];
                tss += Math.pow(actual - meanY, 2);
                rss += Math.pow(actual - predicted, 2);
            }

            // RÂ² = 1 - (RSS / TSS)
            return tss !== 0 ? 1 - (rss / tss) : 0;
        }

        // Aggregate CTE by sector
        function aggregateBySector(equityResults) {
            const sectorAggregation = document.getElementById('sectorAggregation').value;
            const sectors = {};

            equityResults.forEach(eq => {
                let sectorKey = eq.sector;

                // Apply aggregation mapping if custom6 is selected
                if (sectorAggregation === 'custom6') {
                    sectorKey = sectorAggregationMap[eq.sector] || eq.sector;
                }

                if (!sectors[sectorKey]) {
                    sectors[sectorKey] = {
                        cte: 0,
                        contributionToReturn: 0,
                        totalWeightedReturn: 0,
                        totalWeightedActiveReturn: 0,
                        totalWeight: 0
                    };
                }
                sectors[sectorKey].cte += eq.cte;
                sectors[sectorKey].contributionToReturn += eq.contributionToReturn;
                sectors[sectorKey].totalWeightedReturn += eq.return * eq.portfolioWeight;
                sectors[sectorKey].totalWeightedActiveReturn += eq.activeReturn * eq.portfolioWeight;
                sectors[sectorKey].totalWeight += eq.portfolioWeight;
            });

            // Calculate totals for percentages
            const totalCTE = Object.values(sectors).reduce((sum, s) => sum + s.cte, 0);
            const totalContributionToReturn = Object.values(sectors).reduce((sum, s) => sum + s.contributionToReturn, 0);

            return Object.entries(sectors).map(([sector, data]) => ({
                sector,
                return: data.totalWeight > 0 ? data.totalWeightedReturn / data.totalWeight : 0,
                activeReturn: data.totalWeight > 0 ? data.totalWeightedActiveReturn / data.totalWeight : 0,
                cte: data.cte,
                pctOfReturn: totalContributionToReturn !== 0 ? (data.contributionToReturn / totalContributionToReturn) * 100 : 0,
                pctOfTE: totalCTE !== 0 ? (data.cte / totalCTE) * 100 : 0
            })).sort((a, b) => Math.abs(b.cte) - Math.abs(a.cte));
        }

        // Display sleeve attribution
        function displaySleeveAttribution(results) {
            const section = document.getElementById('sleeveAttributionSection');
            const tbody = document.getElementById('sleeveAttributionBody');

            // Check if multiple sleeves are enabled
            const hasMultipleSleeves = portfolio.passiveIndex.enabled || portfolio.alpha.enabled;

            if (!hasMultipleSleeves) {
                section.style.display = 'none';
                return;
            }

            section.style.display = 'block';
            tbody.innerHTML = '';

            // Calculate sleeve-level metrics by grouping equity data
            const sleeveContributions = {};

            console.log('\n===== Sleeve Attribution Debug =====');
            results.equityResults.forEach(eq => {
                const sleeve = eq.sleeve || 'Managed Core';
                console.log(`${eq.ticker}: sleeve="${sleeve}", CTE=${eq.cte.toFixed(4)}%`);

                if (!sleeveContributions[sleeve]) {
                    sleeveContributions[sleeve] = {
                        cte: 0,
                        contributionToReturn: 0,
                        totalWeightedReturn: 0,
                        totalWeightedActiveReturn: 0,
                        totalWeight: 0
                    };
                }
                sleeveContributions[sleeve].cte += eq.cte;
                sleeveContributions[sleeve].contributionToReturn += eq.contributionToReturn;
                sleeveContributions[sleeve].totalWeightedReturn += eq.return * eq.portfolioWeight;
                sleeveContributions[sleeve].totalWeightedActiveReturn += eq.activeReturn * eq.portfolioWeight;
                sleeveContributions[sleeve].totalWeight += eq.portfolioWeight;
            });

            console.log('\nSleeve Totals:');
            Object.entries(sleeveContributions).forEach(([sleeve, data]) => {
                console.log(`  ${sleeve}: CTE = ${data.cte.toFixed(4)}%`);
            });

            // Calculate totals for percentages
            const totalCTE = Object.values(sleeveContributions).reduce((sum, s) => sum + s.cte, 0);
            const totalContributionToReturn = Object.values(sleeveContributions).reduce((sum, s) => sum + s.contributionToReturn, 0);

            // Display each sleeve's contribution
            const sleeves = [
                { name: 'Managed Core', enabled: portfolio.managedCore.enabled, weight: portfolio.managedCore.weight },
                { name: 'Passive Index', enabled: portfolio.passiveIndex.enabled, weight: portfolio.passiveIndex.weight },
                { name: 'Alpha Sleeve', enabled: portfolio.alpha.enabled, weight: portfolio.alpha.weight }
            ];

            let passiveIndexCTE = 0;
            let passiveIndexReturn = 0;
            let passiveIndexActiveReturn = 0;
            let benchmarkRemainderCTE = 0;
            let netIndexWeight = 0;

            sleeves.forEach(sleeve => {
                if (!sleeve.enabled) return;

                const sleeveData = sleeveContributions[sleeve.name] || { cte: 0, totalWeightedReturn: 0, totalWeightedActiveReturn: 0, totalWeight: 0 };
                const cte = sleeveData.cte;
                const sleeveReturn = sleeveData.totalWeight > 0 ? sleeveData.totalWeightedReturn / sleeveData.totalWeight : 0;
                const sleeveActiveReturn = sleeveData.totalWeight > 0 ? sleeveData.totalWeightedActiveReturn / sleeveData.totalWeight : 0;

                // Track Passive Index data for net calculation
                if (sleeve.name === 'Passive Index') {
                    passiveIndexCTE = cte;
                    passiveIndexReturn = sleeveReturn;
                    passiveIndexActiveReturn = sleeveActiveReturn;
                    netIndexWeight = sleeve.weight;
                    // Don't add row - we'll show Net Index Exposure instead
                    return;
                }

                const pctOfReturn = totalContributionToReturn !== 0 ? (sleeveData.contributionToReturn / totalContributionToReturn) * 100 : 0;
                const pctOfTE = totalCTE !== 0 ? (cte / totalCTE) * 100 : 0;

                const row = tbody.insertRow();
                row.innerHTML = `
                    <td><span class="sleeve-badge sleeve-${sleeve.name.toLowerCase().replace(' ', '-')}">${sleeve.name}</span></td>
                    <td>${sleeve.weight.toFixed(1)}</td>
                    <td class="${sleeveActiveReturn >= 0 ? 'positive' : 'negative'}">${sleeveActiveReturn.toFixed(2)}</td>
                    <td class="${cte >= 0 ? 'positive' : 'negative'}">${cte.toFixed(2)}</td>
                    <td class="${pctOfReturn >= 0 ? 'positive' : 'negative'}">${pctOfReturn.toFixed(1)}</td>
                    <td>${pctOfTE.toFixed(1)}</td>
                `;
            });

            // Track Benchmark Remainder (don't show it separately)
            let benchmarkRemainderContributionToReturn = 0;
            if (sleeveContributions['Benchmark Remainder']) {
                benchmarkRemainderCTE = sleeveContributions['Benchmark Remainder'].cte;
                benchmarkRemainderContributionToReturn = sleeveContributions['Benchmark Remainder'].contributionToReturn;
            }

            // Add Net Index Exposure row (only if passive index is enabled)
            if (portfolio.passiveIndex.enabled) {
                const netCTE = passiveIndexCTE + benchmarkRemainderCTE;
                const passiveIndexContributionToReturn = sleeveContributions['Passive Index']?.contributionToReturn || 0;
                const netContributionToReturn = passiveIndexContributionToReturn + benchmarkRemainderContributionToReturn;
                const netPctOfReturn = totalContributionToReturn !== 0 ? (netContributionToReturn / totalContributionToReturn) * 100 : 0;
                const netPctOfTE = totalCTE !== 0 ? (netCTE / totalCTE) * 100 : 0;

                const row = tbody.insertRow();
                row.innerHTML = `
                    <td><span class="sleeve-badge" style="background: #6c757d;">Net Index Exposure</span></td>
                    <td>${netIndexWeight.toFixed(1)}</td>
                    <td class="${passiveIndexActiveReturn >= 0 ? 'positive' : 'negative'}">${passiveIndexActiveReturn.toFixed(2)}</td>
                    <td class="${netCTE >= 0 ? 'positive' : 'negative'}">${netCTE.toFixed(2)}</td>
                    <td class="${netPctOfReturn >= 0 ? 'positive' : 'negative'}">${netPctOfReturn.toFixed(1)}</td>
                    <td>${netPctOfTE.toFixed(1)}</td>
                `;
            }
        }

        // Display sleeve summary
        function displaySleeveSummary(results) {
            const tbody = document.getElementById('sleeveSummaryBody');
            tbody.innerHTML = '';

            // Calculate sleeve-level weights by grouping equity data
            const sleeveSummary = {};

            results.equityResults.forEach(eq => {
                const sleeve = eq.sleeve || 'Managed Core';
                if (!sleeveSummary[sleeve]) {
                    sleeveSummary[sleeve] = {
                        portfolioWeight: 0,
                        benchmarkWeight: 0
                    };
                }
                sleeveSummary[sleeve].portfolioWeight += eq.portfolioWeight;
                sleeveSummary[sleeve].benchmarkWeight += eq.benchmarkWeight;
            });

            // Display each sleeve's summary
            const sleeves = [
                { name: 'Managed Core', enabled: portfolio.managedCore.enabled },
                { name: 'Passive Index', enabled: portfolio.passiveIndex.enabled },
                { name: 'Alpha Sleeve', enabled: portfolio.alpha.enabled },
                { name: 'Benchmark Remainder', enabled: true } // Always check for remainder
            ];

            sleeves.forEach(sleeve => {
                const sleeveData = sleeveSummary[sleeve.name];
                if (!sleeveData) return; // Skip if sleeve has no holdings

                const portfolioWeight = sleeveData.portfolioWeight;
                const benchmarkWeight = sleeveData.benchmarkWeight;
                const activeWeight = portfolioWeight - benchmarkWeight;

                const row = tbody.insertRow();
                row.innerHTML = `
                    <td><span class="sleeve-badge sleeve-${sleeve.name.toLowerCase().replace(' ', '-')}">${sleeve.name}</span></td>
                    <td>${portfolioWeight.toFixed(2)}</td>
                    <td>${benchmarkWeight.toFixed(2)}</td>
                    <td class="${activeWeight >= 0 ? 'positive' : 'negative'}">${activeWeight.toFixed(2)}</td>
                `;
            });

            // Add totals row
            const totalPortfolioWeight = Object.values(sleeveSummary).reduce((sum, s) => sum + s.portfolioWeight, 0);
            const totalBenchmarkWeight = Object.values(sleeveSummary).reduce((sum, s) => sum + s.benchmarkWeight, 0);
            const totalActiveWeight = totalPortfolioWeight - totalBenchmarkWeight;

            const totalRow = tbody.insertRow();
            totalRow.innerHTML = `
                <td><strong>Total</strong></td>
                <td><strong>${totalPortfolioWeight.toFixed(2)}</strong></td>
                <td><strong>${totalBenchmarkWeight.toFixed(2)}</strong></td>
                <td class="${totalActiveWeight >= 0 ? 'positive' : 'negative'}"><strong>${totalActiveWeight.toFixed(2)}</strong></td>
            `;
        }

        // Display results
        function displayResults(results) {
            // Update metric cards
            const portfolioReturn = results.portfolioTotalReturn || 0;
            const benchmarkReturn = results.benchmarkReturn || 0;
            const activeReturn = results.portfolioActiveReturn || 0;

            document.getElementById('portfolioReturn').textContent = portfolioReturn.toFixed(2) + '%';
            document.getElementById('benchmarkReturn').textContent = benchmarkReturn.toFixed(2) + '%';
            document.getElementById('activeReturn').textContent = activeReturn.toFixed(2) + '%';
            document.getElementById('portfolioTE').textContent = results.portfolioTE.toFixed(2) + '%';
            document.getElementById('numHoldings').textContent = results.numHoldings;

            // Apply color classes to return cards
            const portfolioReturnEl = document.getElementById('portfolioReturn');
            const benchmarkReturnEl = document.getElementById('benchmarkReturn');
            const activeReturnEl = document.getElementById('activeReturn');

            portfolioReturnEl.className = 'metric-value ' + (portfolioReturn >= 0 ? 'positive' : 'negative');
            benchmarkReturnEl.className = 'metric-value ' + (benchmarkReturn >= 0 ? 'positive' : 'negative');
            activeReturnEl.className = 'metric-value ' + (activeReturn >= 0 ? 'positive' : 'negative');

            // Display period or custom date range
            if (results.period === 'custom') {
                const startDate = document.getElementById('startDate').value;
                const endDate = document.getElementById('endDate').value;
                document.getElementById('analysisPeriod').textContent = `${startDate} to ${endDate}`;
            } else {
                document.getElementById('analysisPeriod').textContent = results.period.toUpperCase();
            }

            // ========== SLEEVE ATTRIBUTION SECTION ==========
            displaySleeveAttribution(results);

            // Populate equity results table
            const equityTbody = document.getElementById('equityResultsBody');
            equityTbody.innerHTML = '';

            // Separate regular equities from passive index funds
            const regularEquities = [];
            const passiveIndexFunds = [];

            results.equityResults.forEach(eq => {
                // Skip OTHER_SPXE, OTHER_SPX, and benchmark tickers
                if (eq.ticker === 'OTHER_SPXE' || eq.ticker === 'OTHER_SPX') {
                    return;
                }

                // Separate passive index funds (VOO, SPXE, SPY)
                if (eq.ticker === 'VOO' || eq.ticker === 'SPXE' || eq.ticker === 'SPY') {
                    passiveIndexFunds.push(eq);
                } else {
                    regularEquities.push(eq);
                }
            });

            // Display regular equities first
            regularEquities.forEach(eq => {
                const row = equityTbody.insertRow();
                row.innerHTML = `
                    <td>${eq.ticker}</td>
                    <td>${eq.sector}</td>
                    <td class="${eq.activeWeight >= 0 ? 'positive' : 'negative'}" style="text-align: center;">${eq.activeWeight.toFixed(2)}</td>
                    <td class="${eq.return >= 0 ? 'positive' : 'negative'}" style="text-align: center;">${eq.return.toFixed(2)}</td>
                    <td class="${eq.activeReturn >= 0 ? 'positive' : 'negative'}" style="text-align: center;">${eq.activeReturn.toFixed(2)}</td>
                    <td class="${eq.cte >= 0 ? 'positive' : 'negative'}" style="text-align: center;">${eq.cte.toFixed(2)}</td>
                    <td class="${eq.pctOfReturn >= 0 ? 'positive' : 'negative'}" style="text-align: center;">${eq.pctOfReturn.toFixed(1)}</td>
                    <td style="text-align: center;">${eq.pctOfTE.toFixed(1)}</td>
                `;
            });

            // Display passive index funds at the bottom
            passiveIndexFunds.forEach(eq => {
                const row = equityTbody.insertRow();
                row.style.borderTop = '2px solid #ccc';
                row.innerHTML = `
                    <td><strong>${eq.ticker}</strong></td>
                    <td>${eq.sector}</td>
                    <td class="${eq.activeWeight >= 0 ? 'positive' : 'negative'}" style="text-align: center;">${eq.activeWeight.toFixed(2)}</td>
                    <td class="${eq.return >= 0 ? 'positive' : 'negative'}" style="text-align: center;">${eq.return.toFixed(2)}</td>
                    <td class="${eq.activeReturn >= 0 ? 'positive' : 'negative'}" style="text-align: center;">${eq.activeReturn.toFixed(2)}</td>
                    <td class="${eq.cte >= 0 ? 'positive' : 'negative'}" style="text-align: center;">${eq.cte.toFixed(2)}</td>
                    <td class="${eq.pctOfReturn >= 0 ? 'positive' : 'negative'}" style="text-align: center;">${eq.pctOfReturn.toFixed(1)}</td>
                    <td style="text-align: center;">${eq.pctOfTE.toFixed(1)}</td>
                `;
            });

            // Populate sector results table
            const sectorTbody = document.getElementById('sectorResultsBody');
            sectorTbody.innerHTML = '';

            // Separate sectors into categories
            let indexFundSector = null;
            let otherSector = null;
            let alphaSectors = [];
            let regularSectors = [];

            results.sectorResults.forEach(sector => {
                if (sector.sector === 'Index Fund') {
                    indexFundSector = sector;
                } else if (sector.sector === 'Other') {
                    otherSector = sector;
                } else if (sector.sector === 'Alpha') {
                    alphaSectors.push(sector);
                } else {
                    regularSectors.push(sector);
                }
            });

            // Display Alpha sectors first
            alphaSectors.forEach(sector => {
                const row = sectorTbody.insertRow();
                row.innerHTML = `
                    <td>${sector.sector}</td>
                    <td class="${sector.activeReturn >= 0 ? 'positive' : 'negative'}">${sector.activeReturn.toFixed(2)}</td>
                    <td class="${sector.cte >= 0 ? 'positive' : 'negative'}">${sector.cte.toFixed(2)}</td>
                    <td class="${sector.pctOfReturn >= 0 ? 'positive' : 'negative'}">${sector.pctOfReturn.toFixed(1)}</td>
                    <td>${sector.pctOfTE.toFixed(1)}</td>
                `;
            });

            // Display regular sectors
            regularSectors.forEach(sector => {
                const row = sectorTbody.insertRow();
                row.innerHTML = `
                    <td>${sector.sector}</td>
                    <td class="${sector.activeReturn >= 0 ? 'positive' : 'negative'}">${sector.activeReturn.toFixed(2)}</td>
                    <td class="${sector.cte >= 0 ? 'positive' : 'negative'}">${sector.cte.toFixed(2)}</td>
                    <td class="${sector.pctOfReturn >= 0 ? 'positive' : 'negative'}">${sector.pctOfReturn.toFixed(1)}</td>
                    <td>${sector.pctOfTE.toFixed(1)}</td>
                `;
            });

            // Combine Index Fund and Other into Net Index Exposure at the bottom
            if (indexFundSector && otherSector) {
                const netCTE = indexFundSector.cte + otherSector.cte;
                const netActiveReturn = indexFundSector.activeReturn;
                const netPctOfReturn = indexFundSector.pctOfReturn + otherSector.pctOfReturn;
                const netPctOfTE = indexFundSector.pctOfTE + otherSector.pctOfTE;

                const row = sectorTbody.insertRow();
                row.innerHTML = `
                    <td><strong>Net Index Exposure</strong></td>
                    <td class="${netActiveReturn >= 0 ? 'positive' : 'negative'}">${netActiveReturn.toFixed(2)}</td>
                    <td class="${netCTE >= 0 ? 'positive' : 'negative'}">${netCTE.toFixed(2)}</td>
                    <td class="${netPctOfReturn >= 0 ? 'positive' : 'negative'}">${netPctOfReturn.toFixed(1)}</td>
                    <td>${netPctOfTE.toFixed(1)}</td>
                `;
            } else if (indexFundSector) {
                // Only index fund, no "Other" to net against
                const row = sectorTbody.insertRow();
                row.innerHTML = `
                    <td>${indexFundSector.sector}</td>
                    <td class="${indexFundSector.activeReturn >= 0 ? 'positive' : 'negative'}">${indexFundSector.activeReturn.toFixed(2)}</td>
                    <td class="${indexFundSector.cte >= 0 ? 'positive' : 'negative'}">${indexFundSector.cte.toFixed(2)}</td>
                    <td class="${indexFundSector.pctOfReturn >= 0 ? 'positive' : 'negative'}">${indexFundSector.pctOfReturn.toFixed(1)}</td>
                    <td>${indexFundSector.pctOfTE.toFixed(1)}</td>
                `;
            } else if (otherSector) {
                // Only "Other", no index fund
                const row = sectorTbody.insertRow();
                row.innerHTML = `
                    <td>${otherSector.sector}</td>
                    <td class="${otherSector.activeReturn >= 0 ? 'positive' : 'negative'}">${otherSector.activeReturn.toFixed(2)}</td>
                    <td class="${otherSector.cte >= 0 ? 'positive' : 'negative'}">${otherSector.cte.toFixed(2)}</td>
                    <td class="${otherSector.pctOfReturn >= 0 ? 'positive' : 'negative'}">${otherSector.pctOfReturn.toFixed(1)}</td>
                    <td>${otherSector.pctOfTE.toFixed(1)}</td>
                `;
            }

            // Populate portfolio summary table
            const summaryBody = document.getElementById('portfolioSummaryBody');
            summaryBody.innerHTML = '';

            const addSummaryRow = (metric, value, valueClass = '') => {
                const row = summaryBody.insertRow();
                row.innerHTML = `
                    <td>${metric}</td>
                    <td class="${valueClass}">${value}</td>
                `;
            };

            const activeRet = (results.portfolioActiveReturn ?? results.portfolioReturn);
            const portfolioTotalRet = results.portfolioTotalReturn || activeRet;
            const benchmarkRet = results.benchmarkReturn || 0;
            const portfolioBeta = results.portfolioBeta || 1.0;
            const betaReturn = results.betaReturn || 0;
            const alpha = results.alpha || activeRet;
            const informationRatio = results.informationRatio || 0;

            // Portfolio Summary - Key Metrics at Top
            addSummaryRow('Portfolio Return (Annualized, %)', `${portfolioTotalRet.toFixed(2)}%`, portfolioTotalRet >= 0 ? 'positive' : 'negative');
            addSummaryRow('Benchmark Return (Annualized, %)', `${benchmarkRet.toFixed(2)}%`, benchmarkRet >= 0 ? 'positive' : 'negative');
            addSummaryRow('Active Return (Portfolio - Benchmark, %)', `${activeRet.toFixed(2)}%`, activeRet >= 0 ? 'positive' : 'negative');

            // Add empty row for spacing
            const spacerRow1 = summaryBody.insertRow();
            spacerRow1.innerHTML = '<td colspan="2" style="height: 10px; border: none;"></td>';

            // Return Decomposition Section (CAPM/Jensen's Alpha)
            addSummaryRow('Portfolio Beta', portfolioBeta.toFixed(3), '');
            addSummaryRow('Beta Return (Market Exposure, %)', `${betaReturn.toFixed(2)}%`, betaReturn >= 0 ? 'positive' : 'negative');
            addSummaryRow('Alpha (True Skill, %)', `${alpha.toFixed(2)}%`, alpha >= 0 ? 'positive' : 'negative');

            // Add empty row for spacing
            const spacerRow2 = summaryBody.insertRow();
            spacerRow2.innerHTML = '<td colspan="2" style="height: 10px; border: none;"></td>';

            // Risk Metrics Section
            addSummaryRow('Portfolio Tracking Error (Annualized, %)', `${results.portfolioTE.toFixed(2)}%`);
            addSummaryRow('Information Ratio (Alpha / TE)', informationRatio.toFixed(3), informationRatio >= 0 ? 'positive' : 'negative');

            // Display verification
            const verification = document.getElementById('verification');
            const v = results.verification;

            let statusMessage;
            if (v.verified) {
                statusMessage = 'âœ“ Verified - CTEs sum to Portfolio TE';
            } else if (v.percentError < 1) {
                statusMessage = 'âš  Minor deviation - Acceptable (likely due to rounding)';
            } else {
                statusMessage = 'âš  Warning - Significant verification error';
            }

            verification.innerHTML = `
                <strong>Verification:</strong><br>
                Sum of CTEs: ${v.sumOfCTE.toFixed(4)}%<br>
                Portfolio TE: ${v.portfolioTE.toFixed(4)}%<br>
                Absolute Difference: ${v.difference.toFixed(6)}%<br>
                Percent Error: ${v.percentError.toFixed(2)}%<br>
                ${statusMessage}
            `;

            // Update equity curve subtitle
            const subtitle = document.getElementById('equityCurveSubtitle');
            subtitle.textContent = `Start: $10,000 â€¢ End: Portfolio $${results.equityCurve?.portfolioEnd?.toFixed?.(0) ?? '-'} vs Benchmark $${results.equityCurve?.benchmarkEnd?.toFixed?.(0) ?? '-'}`;

            // Render equity curve chart
            if (results.equityCurve && results.equityCurve.portfolio && results.equityCurve.benchmark) {
                renderEquityCurveChart(
                    results.equityCurve.portfolio,
                    results.equityCurve.benchmark,
                    results.equityCurve.startValue
                );
            }
        }

        function buildEquityCurveFromLogReturns(logReturns, startValue) {
            const curve = [startValue];
            for (let i = 0; i < logReturns.length; i++) {
                curve.push(curve[curve.length - 1] * Math.exp(logReturns[i]));
            }
            return curve;
        }

        function renderEquityCurveChart(portfolioCurve, benchmarkCurve, startValue) {
            const svg = document.getElementById('equityCurveSvg');
            if (!svg) return;

            const n = Math.min(portfolioCurve.length, benchmarkCurve.length);
            if (n < 2) {
                svg.innerHTML = '';
                return;
            }

            const width = 900;
            const height = 260;
            const padding = { left: 60, right: 20, top: 14, bottom: 32 };

            const p = portfolioCurve.slice(0, n);
            const b = benchmarkCurve.slice(0, n);

            const all = p.concat(b);
            const minY = Math.min(...all);
            const maxY = Math.max(...all);

            const yMin = Math.min(minY, startValue);
            const yMax = Math.max(maxY, startValue);
            const yRange = (yMax - yMin) || 1;

            const xToSvg = (i) => {
                const x0 = padding.left;
                const x1 = width - padding.right;
                return x0 + (i / (n - 1)) * (x1 - x0);
            };

            const yToSvg = (v) => {
                const y0 = padding.top;
                const y1 = height - padding.bottom;
                return y1 - ((v - yMin) / yRange) * (y1 - y0);
            };

            const makePath = (arr) => {
                let d = '';
                for (let i = 0; i < n; i++) {
                    const x = xToSvg(i);
                    const y = yToSvg(arr[i]);
                    d += (i === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`);
                }
                return d;
            };

            const fmtMoney = (v) => {
                if (!isFinite(v)) return '';
                return `$${Math.round(v).toLocaleString()}`;
            };

            // Build ticks
            const ticks = 4;
            const tickVals = [];
            for (let i = 0; i <= ticks; i++) {
                tickVals.push(yMin + (i / ticks) * yRange);
            }

            const grid = tickVals.map(v => {
                const y = yToSvg(v);
                return `<line class="gridline" x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" />
                        <text class="axis-label" x="${padding.left - 8}" y="${y + 4}" text-anchor="end">${fmtMoney(v)}</text>`;
            }).join('');

            const axis = `
                <line class="axis-line" x1="${padding.left}" y1="${padding.top}" x2="${padding.left}" y2="${height - padding.bottom}" />
                <line class="axis-line" x1="${padding.left}" y1="${height - padding.bottom}" x2="${width - padding.right}" y2="${height - padding.bottom}" />
            `;

            const portfolioPath = makePath(p);
            const benchmarkPath = makePath(b);

            svg.innerHTML = `
                <rect x="0" y="0" width="${width}" height="${height}" fill="white" />
                ${grid}
                ${axis}
                <path d="${benchmarkPath}" fill="none" stroke="#2ea44f" stroke-width="2" />
                <path d="${portfolioPath}" fill="none" stroke="#667eea" stroke-width="2.5" />
            `;
        }

        function renderScatterPlot(portfolioReturns, benchmarkReturns, beta) {
            const svg = document.getElementById('scatterChartSvg');
            if (!svg) return;

            const n = Math.min(portfolioReturns.length, benchmarkReturns.length);
            if (n < 2) {
                svg.innerHTML = '';
                return;
            }

            const width = 900;
            const height = 400;
            const padding = { left: 70, right: 30, top: 30, bottom: 50 };

            // Convert log returns to percentage returns for display
            const pReturns = portfolioReturns.map(r => r * 100);
            const bReturns = benchmarkReturns.map(r => r * 100);

            // Find min/max for both axes
            const minX = Math.min(...bReturns);
            const maxX = Math.max(...bReturns);
            const minY = Math.min(...pReturns);
            const maxY = Math.max(...pReturns);

            // Make axes symmetric around zero
            const maxAbsX = Math.max(Math.abs(minX), Math.abs(maxX));
            const maxAbsY = Math.max(Math.abs(minY), Math.abs(maxY));
            const xRange = maxAbsX * 2;
            const yRange = maxAbsY * 2;

            const xToSvg = (v) => {
                const x0 = padding.left;
                const x1 = width - padding.right;
                return x0 + ((v + maxAbsX) / xRange) * (x1 - x0);
            };

            const yToSvg = (v) => {
                const y0 = padding.top;
                const y1 = height - padding.bottom;
                return y1 - ((v + maxAbsY) / yRange) * (y1 - y0);
            };

            // Draw points
            const points = [];
            for (let i = 0; i < n; i++) {
                const x = xToSvg(bReturns[i]);
                const y = yToSvg(pReturns[i]);
                points.push(`<circle cx="${x}" cy="${y}" r="2.5" fill="#667eea" opacity="0.5" />`);
            }

            // Draw regression line: y = beta * x (both in percentage terms)
            const regressionX1 = xToSvg(-maxAbsX);
            const regressionY1 = yToSvg(-maxAbsX * beta);
            const regressionX2 = xToSvg(maxAbsX);
            const regressionY2 = yToSvg(maxAbsX * beta);

            // Build axis ticks
            const ticks = 5;
            const xTickVals = [];
            const yTickVals = [];
            for (let i = 0; i <= ticks; i++) {
                xTickVals.push(-maxAbsX + (i / ticks) * xRange);
                yTickVals.push(-maxAbsY + (i / ticks) * yRange);
            }

            const xGrid = xTickVals.map(v => {
                const x = xToSvg(v);
                return `<line class="gridline" x1="${x}" y1="${padding.top}" x2="${x}" y2="${height - padding.bottom}" />
                        <text class="axis-label" x="${x}" y="${height - padding.bottom + 20}" text-anchor="middle">${v.toFixed(1)}%</text>`;
            }).join('');

            const yGrid = yTickVals.map(v => {
                const y = yToSvg(v);
                return `<line class="gridline" x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" />
                        <text class="axis-label" x="${padding.left - 10}" y="${y + 4}" text-anchor="end">${v.toFixed(1)}%</text>`;
            }).join('');

            // Draw zero lines
            const zeroX = xToSvg(0);
            const zeroY = yToSvg(0);
            const zeroLines = `
                <line x1="${zeroX}" y1="${padding.top}" x2="${zeroX}" y2="${height - padding.bottom}" stroke="#000" stroke-width="1.5" />
                <line x1="${padding.left}" y1="${zeroY}" x2="${width - padding.right}" y2="${zeroY}" stroke="#000" stroke-width="1.5" />
            `;

            // Axis labels
            const axisLabels = `
                <text x="${width / 2}" y="${height - 10}" text-anchor="middle" font-size="14" font-weight="bold">Benchmark Return (%)</text>
                <text x="${20}" y="${height / 2}" text-anchor="middle" font-size="14" font-weight="bold" transform="rotate(-90, 20, ${height / 2})">Portfolio Return (%)</text>
            `;

            const axis = `
                <line class="axis-line" x1="${padding.left}" y1="${padding.top}" x2="${padding.left}" y2="${height - padding.bottom}" />
                <line class="axis-line" x1="${padding.left}" y1="${height - padding.bottom}" x2="${width - padding.right}" y2="${height - padding.bottom}" />
            `;

            svg.innerHTML = `
                <rect x="0" y="0" width="${width}" height="${height}" fill="white" />
                ${xGrid}
                ${yGrid}
                ${axis}
                ${zeroLines}
                ${points.join('')}
                <line x1="${regressionX1}" y1="${regressionY1}" x2="${regressionX2}" y2="${regressionY2}" stroke="#ef4444" stroke-width="2.5" />
                ${axisLabels}
            `;
        }

        function renderTEChart(rollingTESeries, timestamps, rollingWindow) {
            const svg = document.getElementById('teChartSvg');
            if (!svg) return;

            const n = rollingTESeries.length;
            if (n < 2) {
                svg.innerHTML = '';
                return;
            }

            const width = 900;
            const height = 260;
            const padding = { left: 60, right: 20, top: 14, bottom: 50 };

            // Get timestamps for rolling window (offset by window size)
            const rollingTimestamps = timestamps.slice(rollingWindow);

            const minTE = Math.min(...rollingTESeries);
            const maxTE = Math.max(...rollingTESeries);

            const yMin = Math.max(0, minTE - 1);
            const yMax = maxTE + 1;
            const yRange = (yMax - yMin) || 1;

            const xToSvg = (i) => {
                const x0 = padding.left;
                const x1 = width - padding.right;
                return x0 + (i / (n - 1)) * (x1 - x0);
            };

            const yToSvg = (v) => {
                const y0 = padding.top;
                const y1 = height - padding.bottom;
                return y1 - ((v - yMin) / yRange) * (y1 - y0);
            };

            const makePath = (arr) => {
                let d = '';
                for (let i = 0; i < n; i++) {
                    const x = xToSvg(i);
                    const y = yToSvg(arr[i]);
                    d += (i === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`);
                }
                return d;
            };

            // Build ticks
            const ticks = 5;
            const tickVals = [];
            for (let i = 0; i <= ticks; i++) {
                tickVals.push(yMin + (i / ticks) * yRange);
            }

            const grid = tickVals.map(v => {
                const y = yToSvg(v);
                return `<line class="gridline" x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" />
                        <text class="axis-label" x="${padding.left - 8}" y="${y + 4}" text-anchor="end">${v.toFixed(1)}%</text>`;
            }).join('');

            // Add date labels on X-axis
            const dateLabels = [];
            const numDateLabels = 5;
            for (let i = 0; i <= numDateLabels; i++) {
                const idx = Math.floor((i / numDateLabels) * (n - 1));
                const timestamp = rollingTimestamps[idx];
                if (timestamp) {
                    const date = new Date(timestamp);
                    const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: '2-digit' });
                    const x = xToSvg(idx);
                    dateLabels.push(`<text class="axis-label" x="${x}" y="${height - padding.bottom + 20}" text-anchor="middle">${dateStr}</text>`);
                }
            }

            const axis = `
                <line class="axis-line" x1="${padding.left}" y1="${padding.top}" x2="${padding.left}" y2="${height - padding.bottom}" />
                <line class="axis-line" x1="${padding.left}" y1="${height - padding.bottom}" x2="${width - padding.right}" y2="${height - padding.bottom}" />
            `;

            const tePath = makePath(rollingTESeries);

            svg.innerHTML = `
                <rect x="0" y="0" width="${width}" height="${height}" fill="white" />
                ${grid}
                ${axis}
                ${dateLabels.join('')}
                <path d="${tePath}" fill="none" stroke="#8b5cf6" stroke-width="2.5" />
            `;
        }

        function renderBetaChart(rollingBetaSeries, timestamps, rollingWindow) {
            const svg = document.getElementById('betaChartSvg');
            if (!svg) return;

            const n = rollingBetaSeries.length;
            if (n < 2) {
                svg.innerHTML = '';
                return;
            }

            const width = 900;
            const height = 260;
            const padding = { left: 60, right: 20, top: 14, bottom: 50 };

            // Get timestamps for rolling window (offset by window size)
            const rollingTimestamps = timestamps.slice(rollingWindow);

            const minBeta = Math.min(...rollingBetaSeries);
            const maxBeta = Math.max(...rollingBetaSeries);

            // Ensure Beta = 1.0 is always visible
            const yMin = Math.min(minBeta, 0.8);
            const yMax = Math.max(maxBeta, 1.2);
            const yRange = (yMax - yMin) || 1;

            const xToSvg = (i) => {
                const x0 = padding.left;
                const x1 = width - padding.right;
                return x0 + (i / (n - 1)) * (x1 - x0);
            };

            const yToSvg = (v) => {
                const y0 = padding.top;
                const y1 = height - padding.bottom;
                return y1 - ((v - yMin) / yRange) * (y1 - y0);
            };

            const makePath = (arr) => {
                let d = '';
                for (let i = 0; i < n; i++) {
                    const x = xToSvg(i);
                    const y = yToSvg(arr[i]);
                    d += (i === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`);
                }
                return d;
            };

            // Build ticks
            const ticks = 5;
            const tickVals = [];
            for (let i = 0; i <= ticks; i++) {
                tickVals.push(yMin + (i / ticks) * yRange);
            }

            const grid = tickVals.map(v => {
                const y = yToSvg(v);
                return `<line class="gridline" x1="${padding.left}" y1="${y}" x2="${width - padding.right}" y2="${y}" />
                        <text class="axis-label" x="${padding.left - 8}" y="${y + 4}" text-anchor="end">${v.toFixed(2)}</text>`;
            }).join('');

            // Add horizontal line at Beta = 1.0
            const beta1Y = yToSvg(1.0);
            const beta1Line = `<line x1="${padding.left}" y1="${beta1Y}" x2="${width - padding.right}" y2="${beta1Y}" stroke="#94a3b8" stroke-width="1.5" stroke-dasharray="4,4" />`;

            // Add date labels on X-axis
            const dateLabels = [];
            const numDateLabels = 5;
            for (let i = 0; i <= numDateLabels; i++) {
                const idx = Math.floor((i / numDateLabels) * (n - 1));
                const timestamp = rollingTimestamps[idx];
                if (timestamp) {
                    const date = new Date(timestamp);
                    const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: '2-digit' });
                    const x = xToSvg(idx);
                    dateLabels.push(`<text class="axis-label" x="${x}" y="${height - padding.bottom + 20}" text-anchor="middle">${dateStr}</text>`);
                }
            }

            const axis = `
                <line class="axis-line" x1="${padding.left}" y1="${padding.top}" x2="${padding.left}" y2="${height - padding.bottom}" />
                <line class="axis-line" x1="${padding.left}" y1="${height - padding.bottom}" x2="${width - padding.right}" y2="${height - padding.bottom}" />
            `;

            const betaPath = makePath(rollingBetaSeries);

            svg.innerHTML = `
                <rect x="0" y="0" width="${width}" height="${height}" fill="white" />
                ${grid}
                ${axis}
                ${dateLabels.join('')}
                ${beta1Line}
                <path d="${betaPath}" fill="none" stroke="#f59e0b" stroke-width="2.5" />
            `;
        }

        // Patch displayResults with equity curve computation (kept here to avoid large refactors)
        const _displayResultsOriginal = displayResults;
        displayResults = function(results) {
            // Precompute equity curves from available series.
            try {
                const startValue = 10000;
                const portfolioSeries = results.series?.portfolioReturnSeries;
                const benchmarkSeries = results.series?.benchmarkReturns;

                if (Array.isArray(portfolioSeries) && Array.isArray(benchmarkSeries)) {
                    const portfolioCurve = buildEquityCurveFromLogReturns(portfolioSeries, startValue);
                    const benchmarkCurve = buildEquityCurveFromLogReturns(benchmarkSeries, startValue);
                    results.equityCurve = {
                        startValue,
                        portfolio: portfolioCurve,
                        benchmark: benchmarkCurve,
                        portfolioEnd: portfolioCurve[portfolioCurve.length - 1],
                        benchmarkEnd: benchmarkCurve[benchmarkCurve.length - 1]
                    };
                }
            } catch (e) {
                // no-op
            }

            _displayResultsOriginal(results);

            // After original rendering, ensure subtitle reflects computed ends.
            const subtitle = document.getElementById('equityCurveSubtitle');
            if (subtitle && results.equityCurve) {
                subtitle.textContent = `Start: $10,000 â€¢ End: Portfolio $${results.equityCurve.portfolioEnd.toFixed(0)} vs Benchmark $${results.equityCurve.benchmarkEnd.toFixed(0)}`;
            }

            // Render scatter plot
            const portfolioSeries = results.series?.portfolioReturnSeries;
            const benchmarkSeries = results.series?.benchmarkReturns;
            const portfolioBeta = results.portfolioBeta || 1.0;
            if (portfolioSeries && benchmarkSeries && portfolioSeries.length > 0) {
                renderScatterPlot(portfolioSeries, benchmarkSeries, portfolioBeta);
                const scatterSubtitle = document.getElementById('scatterSubtitle');
                if (scatterSubtitle) {
                    const rSquared = calculateRSquared(portfolioSeries, benchmarkSeries, portfolioBeta);
                    scatterSubtitle.textContent = `Beta: ${portfolioBeta.toFixed(3)} â€¢ RÂ²: ${rSquared.toFixed(3)} â€¢ n = ${portfolioSeries.length} observations`;
                }
            }

            // Render rolling TE chart
            const teSeries = results.series?.rollingTESeries;
            const timestamps = results.series?.timestamps || [];
            const rollingWindow = 60; // Must match the window size used in calculation

            if (teSeries && teSeries.length > 0 && timestamps.length > 0) {
                renderTEChart(teSeries, timestamps, rollingWindow);
                const teSubtitle = document.getElementById('teChartSubtitle');
                if (teSubtitle) {
                    const avgTE = teSeries.reduce((sum, te) => sum + te, 0) / teSeries.length;
                    const minTE = Math.min(...teSeries);
                    const maxTE = Math.max(...teSeries);
                    teSubtitle.textContent = `Average: ${avgTE.toFixed(2)}% â€¢ Range: ${minTE.toFixed(2)}% to ${maxTE.toFixed(2)}%`;
                }
            }

            // Render beta chart
            const betaSeries = results.series?.rollingBetaSeries;
            if (betaSeries && betaSeries.length > 0 && timestamps.length > 0) {
                renderBetaChart(betaSeries, timestamps, rollingWindow);
                const betaSubtitle = document.getElementById('betaChartSubtitle');
                if (betaSubtitle) {
                    const avgBeta = betaSeries.reduce((sum, b) => sum + b, 0) / betaSeries.length;
                    const minBeta = Math.min(...betaSeries);
                    const maxBeta = Math.max(...betaSeries);
                    betaSubtitle.textContent = `Average: ${avgBeta.toFixed(3)} â€¢ Range: ${minBeta.toFixed(3)} to ${maxBeta.toFixed(3)}`;
                }
            }
        };

        // Keep a reference to the last full calculation output for debugging/export
        let lastResults = null;
        let equitySortColumn = -1;
        let equitySortAscending = true;

        // Sort equity table by column
        function sortEquityTable(columnIndex) {
            if (!lastResults || !lastResults.equityResults) return;

            // Toggle sort direction if clicking same column
            if (equitySortColumn === columnIndex) {
                equitySortAscending = !equitySortAscending;
            } else {
                equitySortColumn = columnIndex;
                equitySortAscending = true;
            }

            // Separate regular equities from passive index funds
            const regularEquities = [];
            const passiveIndexFunds = [];

            lastResults.equityResults.forEach(eq => {
                // Skip OTHER_SPXE, OTHER_SPX, and benchmark tickers
                if (eq.ticker === 'OTHER_SPXE' || eq.ticker === 'OTHER_SPX' ||
                    eq.ticker === '^GSPC' || eq.ticker === lastResults.benchmark) {
                    return;
                }

                // Separate passive index funds (VOO, SPXE, SPY)
                if (eq.ticker === 'VOO' || eq.ticker === 'SPXE' || eq.ticker === 'SPY') {
                    passiveIndexFunds.push(eq);
                } else {
                    regularEquities.push(eq);
                }
            });

            // Sort the regular equities
            regularEquities.sort((a, b) => {
                let aVal, bVal;

                switch(columnIndex) {
                    case 0: // Ticker
                        aVal = a.ticker;
                        bVal = b.ticker;
                        return equitySortAscending ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                    case 1: // Sector
                        aVal = a.sector;
                        bVal = b.sector;
                        return equitySortAscending ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                    case 2: // Active Weight
                        aVal = a.activeWeight;
                        bVal = b.activeWeight;
                        break;
                    case 3: // Return
                        aVal = a.return;
                        bVal = b.return;
                        break;
                    case 4: // Active Return
                        aVal = a.activeReturn;
                        bVal = b.activeReturn;
                        break;
                    case 5: // CTE
                        aVal = a.cte;
                        bVal = b.cte;
                        break;
                    case 6: // % of Return
                        aVal = a.pctOfReturn;
                        bVal = b.pctOfReturn;
                        break;
                    case 7: // % of TE
                        aVal = a.pctOfTE;
                        bVal = b.pctOfTE;
                        break;
                }

                return equitySortAscending ? aVal - bVal : bVal - aVal;
            });

            // Redraw the table
            const tbody = document.getElementById('equityResultsBody');
            tbody.innerHTML = '';

            // Display regular equities first
            regularEquities.forEach(eq => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>${eq.ticker}</td>
                    <td>${eq.sector}</td>
                    <td class="${eq.activeWeight >= 0 ? 'positive' : 'negative'}" style="text-align: center;">${eq.activeWeight.toFixed(2)}</td>
                    <td class="${eq.return >= 0 ? 'positive' : 'negative'}" style="text-align: center;">${eq.return.toFixed(2)}</td>
                    <td class="${eq.activeReturn >= 0 ? 'positive' : 'negative'}" style="text-align: center;">${eq.activeReturn.toFixed(2)}</td>
                    <td class="${eq.cte >= 0 ? 'positive' : 'negative'}" style="text-align: center;">${eq.cte.toFixed(2)}</td>
                    <td class="${eq.pctOfReturn >= 0 ? 'positive' : 'negative'}" style="text-align: center;">${eq.pctOfReturn.toFixed(1)}</td>
                    <td style="text-align: center;">${eq.pctOfTE.toFixed(1)}</td>
                `;
            });

            // Display passive index funds at the bottom
            passiveIndexFunds.forEach(eq => {
                const row = tbody.insertRow();
                row.style.borderTop = '2px solid #ccc';
                row.innerHTML = `
                    <td><strong>${eq.ticker}</strong></td>
                    <td>${eq.sector}</td>
                    <td class="${eq.activeWeight >= 0 ? 'positive' : 'negative'}" style="text-align: center;">${eq.activeWeight.toFixed(2)}</td>
                    <td class="${eq.return >= 0 ? 'positive' : 'negative'}" style="text-align: center;">${eq.return.toFixed(2)}</td>
                    <td class="${eq.activeReturn >= 0 ? 'positive' : 'negative'}" style="text-align: center;">${eq.activeReturn.toFixed(2)}</td>
                    <td class="${eq.cte >= 0 ? 'positive' : 'negative'}" style="text-align: center;">${eq.cte.toFixed(2)}</td>
                    <td class="${eq.pctOfReturn >= 0 ? 'positive' : 'negative'}" style="text-align: center;">${eq.pctOfReturn.toFixed(1)}</td>
                    <td style="text-align: center;">${eq.pctOfTE.toFixed(1)}</td>
                `;
            });
        }

        function toISODateForCSV(periodIndex) {
            const period = document.getElementById('period')?.value;
            const freq = document.getElementById('frequency')?.value;

            // We don't have trading-day timestamps from Yahoo in this tool, so we provide an index
            // plus optional start/end labels for transparency.
            return `t${periodIndex}`;
        }

        function numberOrBlank(x) {
            return (x === null || x === undefined || !isFinite(x)) ? '' : x;
        }

        function downloadDebugCSV() {
            if (!lastResults || !lastResults.series) {
                alert('Run a calculation first, then download the debug CSV.');
                return;
            }

            const startValue = 10000;
            const portfolioR = lastResults.series.portfolioReturnSeries || [];
            const benchmarkR = lastResults.series.benchmarkReturns || [];
            const activeR = lastResults.series.portfolioActiveReturnSeries || [];
            const weightedActive = lastResults.series.weightedActiveReturns || {};
            const priceData = lastResults.series.priceData || {};

            const n = Math.min(portfolioR.length, benchmarkR.length, activeR.length);
            if (n === 0) {
                alert('No return series available to export.');
                return;
            }

            // Build equity curves (from log returns)
            const portfolioCurve = buildEquityCurveFromLogReturns(portfolioR.slice(0, n), startValue);
            const benchmarkCurve = buildEquityCurveFromLogReturns(benchmarkR.slice(0, n), startValue);

            // Flatten weighted active returns columns by ticker
            const tickers = (lastResults.equityResults || []).map(e => e.ticker);

            // Price columns (note: prices have n+1 points; returns have n points)
            // Handle both old format (array) and new format ({prices, timestamps})
            const priceCols = tickers
                .filter(t => {
                    const data = priceData[t];
                    if (!data) return false;
                    const prices = Array.isArray(data) ? data : data.prices;
                    return Array.isArray(prices) && prices.length >= (n + 1);
                })
                .map(t => `price_${t}`);

            const header = [
                't',
                'portfolio_log_return',
                'benchmark_log_return',
                'active_log_return',
                'portfolio_value_10000',
                'benchmark_value_10000',
                ...tickers.map(t => `weighted_active_return_${t}`),
                ...priceCols
            ];

            const rows = [header.join(',')];

            for (let i = 0; i < n; i++) {
                const line = [
                    toISODateForCSV(i),
                    numberOrBlank(portfolioR[i]),
                    numberOrBlank(benchmarkR[i]),
                    numberOrBlank(activeR[i]),
                    numberOrBlank(portfolioCurve[i + 1]),
                    numberOrBlank(benchmarkCurve[i + 1]),
                    ...tickers.map(t => numberOrBlank((weightedActive[t] || [])[i])),
                    ...priceCols.map(col => {
                        const t = col.replace(/^price_/, '');
                        const data = priceData[t];
                        const prices = data ? (Array.isArray(data) ? data : data.prices) : [];
                        // align: return i uses prices[i] -> prices[i+1]; exporting price at t(i) = prices[i+1]
                        return numberOrBlank(prices[i + 1]);
                    })
                ]
                    .map(v => (typeof v === 'string' ? v : String(v)))
                    .join(',');

                rows.push(line);
            }

            // Add a small footer summary block (prefixed with # so Excel keeps it as text)
            rows.push('#');
            rows.push(`#portfolio_te_pct,${lastResults.portfolioTE}`);
            rows.push(`#sum_cte_pct,${(lastResults.verification && lastResults.verification.sumOfCTE) ? lastResults.verification.sumOfCTE : ''}`);
            rows.push(`#portfolio_active_return_annualized_pct,${(lastResults.portfolioActiveReturn ?? '')}`);
            rows.push(`#benchmark,${lastResults.benchmark}`);
            rows.push(`#period,${lastResults.period}`);

            const csv = rows.join('\n');
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `tracking_error_debug_${lastResults.benchmark}_${new Date().toISOString().slice(0,10)}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            URL.revokeObjectURL(url);
        }

        // Mobile menu functionality
        function initMobileMenu() {
            const mobileToggle = document.getElementById('mobileMenuToggle');
            const navLinks = document.getElementById('navLinks');

            if (!mobileToggle || !navLinks) return;

            mobileToggle.addEventListener('click', function(e) {
                e.preventDefault();
                navLinks.classList.toggle('active');
                mobileToggle.classList.toggle('active');
            });

            navLinks.querySelectorAll('a').forEach(link => {
                link.addEventListener('click', () => {
                    navLinks.classList.remove('active');
                    mobileToggle.classList.remove('active');
                });
            });

            document.addEventListener('click', (e) => {
                if (!mobileToggle.contains(e.target) && !navLinks.contains(e.target)) {
                    navLinks.classList.remove('active');
                    mobileToggle.classList.remove('active');
                }
            });
        }

        // Initialize mobile menu when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initMobileMenu();
        });
    </script>
</body>
</html>
